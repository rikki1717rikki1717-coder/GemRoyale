<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BRAWL CLONE - Gem Battle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lilita+One&family=Rubik:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #FFC107;
            --secondary: #FF9800;
            --blue-team: #007BFF;
            --red-team: #FF3B30;
            --bg-color: #1a1a2e;
            --ui-font: 'Rubik', sans-serif;
            --header-font: 'Lilita One', cursive;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: var(--ui-font);
            color: white;
            height: 100vh;
            width: 100vw;
        }

        /* --- UI LAYERS --- */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #2b2b2b; /* Map Floor Color */
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- MENUS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-family: var(--header-font);
            font-size: 4rem;
            color: var(--primary);
            text-shadow: 4px 4px 0px #000, -2px -2px 0 #fff;
            margin-bottom: 20px;
            letter-spacing: 2px;
            transform: rotate(-3deg);
        }

        .card-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .char-card {
            background: linear-gradient(145deg, #2a2a40, #1f1f30);
            border: 4px solid #444;
            border-radius: 20px;
            padding: 20px;
            width: 160px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .char-card:hover, .char-card.selected {
            transform: translateY(-10px) scale(1.05);
            border-color: var(--primary);
            background: linear-gradient(145deg, #3a3a55, #2f2f45);
        }

        .char-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .char-name {
            font-family: var(--header-font);
            font-size: 1.5rem;
            margin: 0;
            color: white;
        }

        .char-role {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 10px;
        }

        .stat-bar {
            background: #444;
            height: 8px;
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
            position: relative;
        }
        .stat-fill { height: 100%; background: var(--secondary); }

        .btn-start {
            font-family: var(--header-font);
            font-size: 2rem;
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 15px 60px;
            border-radius: 50px;
            border-bottom: 6px solid #1B5E20;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        .btn-start:active {
            transform: translateY(4px);
            border-bottom-width: 2px;
        }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .score-board {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-family: var(--header-font);
            font-size: 2rem;
            text-shadow: 2px 2px 0 #000;
        }

        .score-blue { color: #4fc3f7; display: flex; align-items: center; gap: 5px; }
        .score-red { color: #ff8a80; display: flex; align-items: center; gap: 5px; }
        .gem-icon { color: #d500f9; filter: drop-shadow(0 0 5px #d500f9); }

        /* Joysticks */
        .joystick-zone {
            position: absolute;
            bottom: 40px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        #stick-left { left: 40px; }
        #stick-right { right: 40px; }

        .joystick-base {
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .joystick-handle {
            width: 60px; height: 60px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(200,200,200,0.2));
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.5);
        }
        #stick-right .joystick-handle {
            background-color: rgba(255, 59, 48, 0.4); /* Red tint for attack */
            border-color: rgba(255, 59, 48, 0.8);
        }

        /* --- GAME OVER --- */
        #result-screen h2 {
            font-family: var(--header-font);
            font-size: 5rem;
            margin: 0;
            text-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .win { color: #00E676; text-shadow: 4px 4px 0 #00600f; }
        .lose { color: #FF1744; text-shadow: 4px 4px 0 #8b0000; }

        /* Floating Text Animation */
        .floating-text {
            position: absolute;
            font-family: var(--header-font);
            color: white;
            font-size: 1.2rem;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
            -webkit-text-stroke: 1px black;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="hud" class="hidden">
            <div class="score-board">
                <div class="score-blue"><span id="score-blue-val">0</span> <span class="gem-icon">üíé</span></div>
                <div style="color:white; font-size:1.5rem; margin-top:5px;">vs</div>
                <div class="score-red"><span class="gem-icon">üíé</span> <span id="score-red-val">0</span></div>
            </div>
            
            <div id="stick-left" class="joystick-zone">
                <div class="joystick-base"><div class="joystick-handle"></div></div>
            </div>
            <div id="stick-right" class="joystick-zone">
                <div class="joystick-base"><div class="joystick-handle"></div></div>
            </div>
        </div>

        <div id="main-menu" class="overlay">
            <h1>BRAWL CLONE</h1>
            <p style="color: #ccc; margin-bottom: 20px;">„Ç≠„É£„É©„ÇØ„Çø„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
            
            <div class="card-container">
                <div class="char-card selected" onclick="selectChar('fighter', this)">
                    <div class="char-icon">ü§†</div>
                    <h3 class="char-name">„Éï„Ç°„Ç§„Çø„Éº</h3>
                    <div class="char-role">‰∏≠Ë∑ùÈõ¢ / Êï£Âºæ</div>
                    <div class="stat-bar"><div class="stat-fill" style="width: 70%"></div></div> <div class="stat-bar"><div class="stat-fill" style="width: 80%; background:#ff5252"></div></div> </div>
                <div class="char-card" onclick="selectChar('sniper', this)">
                    <div class="char-icon">üëÆ</div>
                    <h3 class="char-name">„Çπ„Éä„Ç§„Éë„Éº</h3>
                    <div class="char-role">ÈÅ†Ë∑ùÈõ¢ / ÈÄ£Â∞Ñ</div>
                    <div class="stat-bar"><div class="stat-fill" style="width: 50%"></div></div>
                    <div class="stat-bar"><div class="stat-fill" style="width: 95%; background:#ff5252"></div></div>
                </div>
                <div class="char-card" onclick="selectChar('tank', this)">
                    <div class="char-icon">ü§º</div>
                    <h3 class="char-name">„Çø„É≥„ÇØ</h3>
                    <div class="char-role">ËøëË∑ùÈõ¢ / È´òËÄê‰πÖ</div>
                    <div class="stat-bar"><div class="stat-fill" style="width: 100%"></div></div>
                    <div class="stat-bar"><div class="stat-fill" style="width: 60%; background:#ff5252"></div></div>
                </div>
            </div>

            <button class="btn-start" onclick="startGame()">BATTLE!</button>
        </div>

        <div id="result-screen" class="overlay hidden">
            <h2 id="result-title">VICTORY!</h2>
            <p id="result-desc" style="font-size: 1.5rem; color: #fff;">Blue Team Wins</p>
            <button class="btn-start" style="margin-top: 30px;" onclick="resetGame()">PLAY AGAIN</button>
        </div>
    </div>

<script>
/**
 * Game Configuration & Constants
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
const CONFIG = {
    mapWidth: 2000,
    mapHeight: 2000,
    tileSize: 100,
    gemSpawnRate: 300, // Frames
};

let gameActive = false;
let camera = { x: 0, y: 0 };
let playerType = 'fighter';

/**
 * Classes
 */
class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m);
    }
}

class Entity {
    constructor(x, y, radius, color) {
        this.pos = new Vector(x, y);
        this.radius = radius;
        this.color = color;
        this.dead = false;
    }
}

class Brawler extends Entity {
    constructor(x, y, team, type, isBot = false) {
        super(x, y, 35, team === 'blue' ? '#007BFF' : '#FF3B30');
        this.team = team;
        this.type = type;
        this.isBot = isBot;
        this.velocity = new Vector(0, 0);
        this.angle = 0;
        this.gems = 0;
        this.respawnTimer = 0;

        // Stats based on type
        if (type === 'tank') {
            this.maxHp = 6000;
            this.speed = 4;
            this.range = 150;
            this.reloadTime = 40;
            this.damage = 1000;
            this.projectileCount = 1;
            this.spread = 0;
            this.isMelee = true;
        } else if (type === 'sniper') {
            this.maxHp = 2800;
            this.speed = 5;
            this.range = 800;
            this.reloadTime = 30;
            this.damage = 600;
            this.projectileCount = 1;
            this.spread = 0.05;
            this.projectileSpeed = 20;
            this.isMelee = false;
        } else { // fighter (Shelly)
            this.maxHp = 3800;
            this.speed = 4.5;
            this.range = 400;
            this.reloadTime = 50;
            this.damage = 400; // per bullet
            this.projectileCount = 5;
            this.spread = 0.4;
            this.projectileSpeed = 15;
            this.isMelee = false;
        }
        
        this.hp = this.maxHp;
        this.cooldown = 0;
        
        // Bot AI
        this.target = null;
        this.state = 'idle'; // idle, chase, retreat, collect
    }

    update() {
        if (this.dead) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) this.respawn();
            return;
        }

        // Friction
        this.velocity = this.velocity.mult(0.85);
        this.pos = this.pos.add(this.velocity);
        
        // Cooldown
        if (this.cooldown > 0) this.cooldown--;

        // Map Boundaries
        this.pos.x = Math.max(this.radius, Math.min(CONFIG.mapWidth - this.radius, this.pos.x));
        this.pos.y = Math.max(this.radius, Math.min(CONFIG.mapHeight - this.radius, this.pos.y));

        if (this.isBot) this.updateAI();
    }

    shoot(aimVector) {
        if (this.dead || this.cooldown > 0) return;

        this.cooldown = this.reloadTime;
        
        if (this.isMelee) {
            // Melee Attack (Hitscan area)
            // Visual effect
            particles.push(new Particle(this.pos.x + aimVector.x * 40, this.pos.y + aimVector.y * 40, 60, '#fff', 10));
            
            brawlers.forEach(b => {
                if (b.team !== this.team && !b.dead) {
                    let dist = b.pos.sub(this.pos).mag();
                    if (dist < this.range) {
                        b.takeDamage(this.damage);
                    }
                }
            });
        } else {
            // Projectile Attack
            let baseAngle = Math.atan2(aimVector.y, aimVector.x);
            let startAngle = baseAngle - this.spread / 2;
            let step = this.projectileCount > 1 ? this.spread / (this.projectileCount - 1) : 0;

            for (let i = 0; i < this.projectileCount; i++) {
                let angle = startAngle + (step * i);
                let vx = Math.cos(angle) * this.projectileSpeed;
                let vy = Math.sin(angle) * this.projectileSpeed;
                projectiles.push(new Projectile(
                    this.pos.x, this.pos.y, 
                    new Vector(vx, vy), 
                    this.damage, 
                    this.team, 
                    this.range
                ));
            }
        }
    }

    takeDamage(amount) {
        if (this.dead) return;
        this.hp -= amount;
        spawnFloatingText(Math.floor(amount), this.pos.x, this.pos.y - 40, '#ffcc00');
        
        if (this.hp <= 0) {
            this.die();
        }
    }

    die() {
        this.dead = true;
        this.respawnTimer = 180; // 3 seconds
        
        // Drop gems
        let gemsToDrop = Math.floor(this.gems / 2) + 1; // Drop half + 1 base
        this.gems = 0;
        for(let i=0; i<gemsToDrop; i++) {
            gems.push(new Gem(this.pos.x + (Math.random()*40-20), this.pos.y + (Math.random()*40-20)));
        }
        
        updateScore();
        spawnFloatingText("ELIMINATED!", this.pos.x, this.pos.y, 'red');
    }

    respawn() {
        this.dead = false;
        this.hp = this.maxHp;
        // Spawn at base
        if (this.team === 'blue') {
            this.pos = new Vector(100 + Math.random()*100, CONFIG.mapHeight/2 + Math.random()*200 - 100);
        } else {
            this.pos = new Vector(CONFIG.mapWidth - 100 - Math.random()*100, CONFIG.mapHeight/2 + Math.random()*200 - 100);
        }
    }

    updateAI() {
        // Simple AI Logic
        // 1. Find nearest Gem
        // 2. Or Find nearest Enemy
        let nearestGem = null;
        let minGemDist = 9999;
        gems.forEach(g => {
            let d = this.pos.sub(g.pos).mag();
            if (d < minGemDist) { minGemDist = d; nearestGem = g; }
        });

        let nearestEnemy = null;
        let minEnemyDist = 9999;
        brawlers.forEach(b => {
            if (b.team !== this.team && !b.dead) {
                let d = this.pos.sub(b.pos).mag();
                if (d < minEnemyDist) { minEnemyDist = d; nearestEnemy = b; }
            }
        });

        let moveDir = new Vector(0,0);
        let shootDir = null;

        // Decision Tree
        if (nearestEnemy && minEnemyDist < this.range * 0.8) {
            // Fight mode
            shootDir = nearestEnemy.pos.sub(this.pos).normalize();
            // Maintain distance if sniper, close in if tank
            if (this.type === 'sniper' && minEnemyDist < 300) {
                moveDir = this.pos.sub(nearestEnemy.pos).normalize(); // Retreat
            } else {
                moveDir = shootDir;
            }
        } else if (nearestGem && this.gems < 10) {
            // Collect mode
            moveDir = nearestGem.pos.sub(this.pos).normalize();
        } else if (nearestEnemy) {
            // Hunt mode
            moveDir = nearestEnemy.pos.sub(this.pos).normalize();
        } else {
            // Go to center
            moveDir = new Vector(CONFIG.mapWidth/2, CONFIG.mapHeight/2).sub(this.pos).normalize();
        }

        // Apply movement
        this.velocity = this.velocity.add(moveDir.mult(0.5)); // Acceleration
        // Cap speed
        if (this.velocity.mag() > this.speed) {
            this.velocity = this.velocity.normalize().mult(this.speed);
        }

        // Shoot randomly if has target
        if (shootDir && Math.random() < 0.05) {
            this.shoot(shootDir);
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, vel, damage, team, range) {
        super(x, y, 8, '#fff');
        this.velocity = vel;
        this.damage = damage;
        this.team = team;
        this.distanceTravelled = 0;
        this.maxDist = range;
    }

    update() {
        this.pos = this.pos.add(this.velocity);
        this.distanceTravelled += this.velocity.mag();
        if (this.distanceTravelled >= this.maxDist) this.dead = true;

        // Collision Check
        brawlers.forEach(b => {
            if (b.team !== this.team && !b.dead) {
                if (b.pos.sub(this.pos).mag() < b.radius + this.radius) {
                    b.takeDamage(this.damage);
                    this.dead = true;
                    // Hit particles
                    for(let i=0; i<3; i++) particles.push(new Particle(this.pos.x, this.pos.y, 5, this.team === 'blue' ? '#007BFF' : '#FF3B30', 15));
                }
            }
        });
    }
}

class Gem extends Entity {
    constructor(x, y) {
        super(x, y, 10, '#d500f9');
        this.floatOffset = Math.random() * Math.PI * 2;
    }
    
    update() {
        // Collect
        brawlers.forEach(b => {
            if (!b.dead && b.pos.sub(this.pos).mag() < b.radius + this.radius) {
                this.dead = true;
                b.gems++;
                updateScore();
                spawnFloatingText("+1", b.pos.x, b.pos.y - 50, '#d500f9');
            }
        });
    }

    draw(ctx) {
        let bob = Math.sin(Date.now() / 200 + this.floatOffset) * 5;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(this.pos.x, this.pos.y - 10 + bob);
        ctx.lineTo(this.pos.x + 10, this.pos.y + bob);
        ctx.lineTo(this.pos.x, this.pos.y + 10 + bob);
        ctx.lineTo(this.pos.x - 10, this.pos.y + bob);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Particle extends Entity {
    constructor(x, y, radius, color, life) {
        super(x, y, radius, color);
        this.life = life;
        this.maxLife = life;
        this.velocity = new Vector((Math.random()-0.5)*5, (Math.random()-0.5)*5);
    }
    update() {
        this.pos = this.pos.add(this.velocity);
        this.life--;
        if (this.life <= 0) this.dead = true;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

/**
 * Globals
 */
let brawlers = [];
let projectiles = [];
let gems = [];
let particles = [];
let gemSpawnTimer = 0;
let player;

/**
 * Input Handling (Virtual Joysticks)
 */
const inputs = {
    move: new Vector(0,0),
    aim: new Vector(0,0),
    isShooting: false
};

function setupJoystick(elementId, type) {
    const zone = document.getElementById(elementId);
    const handle = zone.querySelector('.joystick-handle');
    let touchId = null;
    let origin = {x:0, y:0};

    zone.addEventListener('touchstart', e => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        touchId = touch.identifier;
        const rect = zone.getBoundingClientRect();
        origin = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        updateStick(touch.clientX, touch.clientY);
    }, {passive: false});

    zone.addEventListener('touchmove', e => {
        e.preventDefault();
        for (let i=0; i<e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                updateStick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            }
        }
    }, {passive: false});

    const endTouch = (e) => {
        e.preventDefault();
        for (let i=0; i<e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                touchId = null;
                handle.style.transform = `translate(-50%, -50%)`;
                if (type === 'move') inputs.move = new Vector(0,0);
                if (type === 'aim') {
                    // Release to shoot
                    if (inputs.aim.mag() > 0.3) {
                        player.shoot(inputs.aim);
                    }
                    inputs.aim = new Vector(0,0);
                    inputs.isShooting = false;
                    handle.style.backgroundColor = '';
                }
            }
        }
    };

    zone.addEventListener('touchend', endTouch);
    zone.addEventListener('touchcancel', endTouch);

    function updateStick(cx, cy) {
        let dx = cx - origin.x;
        let dy = cy - origin.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let maxDist = 40; // Max handle movement
        let angle = Math.atan2(dy, dx);

        if (dist > maxDist) {
            dx = Math.cos(angle) * maxDist;
            dy = Math.sin(angle) * maxDist;
        }

        handle.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        let vec = new Vector(dx/maxDist, dy/maxDist);
        if (type === 'move') inputs.move = vec;
        if (type === 'aim') {
            inputs.aim = vec;
            // Visual feedback for aiming
            if (dist > 10) handle.style.backgroundColor = 'white';
        }
    }
}

// Keyboard fallback for debugging/PC
window.addEventListener('keydown', e => {
    if(e.key==='w') inputs.move.y = -1;
    if(e.key==='s') inputs.move.y = 1;
    if(e.key==='a') inputs.move.x = -1;
    if(e.key==='d') inputs.move.x = 1;
    if(e.key === ' ') player.shoot(new Vector(1,0)); // Shoot right
});
window.addEventListener('keyup', e => {
    if(['w','s'].includes(e.key)) inputs.move.y = 0;
    if(['a','d'].includes(e.key)) inputs.move.x = 0;
});

/**
 * Game Logic
 */
function initGame() {
    setupJoystick('stick-left', 'move');
    setupJoystick('stick-right', 'aim');
    
    // Resize Canvas
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;

    // Start Loop
    loop();
}

function selectChar(type, el) {
    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
    playerType = type;
}

function startGame() {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');

    brawlers = [];
    projectiles = [];
    gems = [];
    particles = [];
    gemSpawnTimer = 0;
    
    // Create Player (Blue Team)
    player = new Brawler(200, CONFIG.mapHeight/2, 'blue', playerType);
    brawlers.push(player);

    // Create Allies (Blue)
    brawlers.push(new Brawler(200, CONFIG.mapHeight/2 - 200, 'blue', 'sniper', true));
    brawlers.push(new Brawler(200, CONFIG.mapHeight/2 + 200, 'blue', 'tank', true));

    // Create Enemies (Red)
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2, 'red', 'fighter', true));
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2 - 200, 'red', 'sniper', true));
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2 + 200, 'red', 'tank', true));

    gameActive = true;
}

function resetGame() {
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('main-menu').classList.remove('hidden');
}

function updateScore() {
    let blueGems = brawlers.filter(b => b.team === 'blue').reduce((a,b) => a + b.gems, 0);
    let redGems = brawlers.filter(b => b.team === 'red').reduce((a,b) => a + b.gems, 0);
    document.getElementById('score-blue-val').innerText = blueGems;
    document.getElementById('score-red-val').innerText = redGems;

    if (blueGems >= 10 || redGems >= 10) {
        // Simple win condition trigger
        setTimeout(() => endGame(blueGems > redGems ? 'blue' : 'red'), 2000);
    }
}

function endGame(winner) {
    if (!gameActive) return;
    gameActive = false;
    document.getElementById('hud').classList.add('hidden');
    const screen = document.getElementById('result-screen');
    const title = document.getElementById('result-title');
    const desc = document.getElementById('result-desc');
    
    screen.classList.remove('hidden');
    if (winner === 'blue') {
        title.innerText = "VICTORY!";
        title.className = "win";
        desc.innerText = "You controlled the mine!";
    } else {
        title.innerText = "DEFEAT";
        title.className = "lose";
        desc.innerText = "Better luck next time...";
    }
}

function spawnFloatingText(text, x, y, color) {
    const div = document.createElement('div');
    div.innerText = text;
    div.className = 'floating-text';
    div.style.left = (x - camera.x + CANVAS.width/2) + 'px';
    div.style.top = (y - camera.y + CANVAS.height/2) + 'px';
    div.style.color = color;
    document.body.appendChild(div);
    setTimeout(() => div.remove(), 800);
}

function loop() {
    requestAnimationFrame(loop);
    
    // Clear
    CTX.fillStyle = '#2b2b2b';
    CTX.fillRect(0,0, CANVAS.width, CANVAS.height);

    if (!gameActive) return;

    // --- LOGIC ---
    
    // Gem Spawner
    gemSpawnTimer++;
    if (gemSpawnTimer > CONFIG.gemSpawnRate && gems.length < 15) {
        gems.push(new Gem(CONFIG.mapWidth/2 + (Math.random()*100-50), CONFIG.mapHeight/2 + (Math.random()*100-50)));
        gemSpawnTimer = 0;
    }

    // Player Input
    if (inputs.move.mag() > 0.1) {
        player.velocity = player.velocity.add(inputs.move.mult(0.8)); // Acceleration
        // Cap speed
        if (player.velocity.mag() > player.speed) {
            player.velocity = player.velocity.normalize().mult(player.speed);
        }
    }

    // Update Entities
    [...gems, ...brawlers, ...projectiles, ...particles].forEach(e => e.update());

    // Cleanup Dead
    projectiles = projectiles.filter(p => !p.dead);
    gems = gems.filter(g => !g.dead);
    particles = particles.filter(p => !p.dead);

    // Camera Follow
    let targetCamX = player.pos.x;
    let targetCamY = player.pos.y;
    camera.x += (targetCamX - camera.x) * 0.1;
    camera.y += (targetCamY - camera.y) * 0.1;

    // --- DRAWING ---
    CTX.save();
    CTX.translate(-camera.x + CANVAS.width/2, -camera.y + CANVAS.height/2);

    // Draw Grid/Floor
    CTX.strokeStyle = '#3a3a4d';
    CTX.lineWidth = 2;
    CTX.beginPath();
    for(let x=0; x<=CONFIG.mapWidth; x+=CONFIG.tileSize) { CTX.moveTo(x,0); CTX.lineTo(x, CONFIG.mapHeight); }
    for(let y=0; y<=CONFIG.mapHeight; y+=CONFIG.tileSize) { CTX.moveTo(0,y); CTX.lineTo(CONFIG.mapWidth, y); }
    CTX.stroke();

    // Draw Safe Zone (Center)
    CTX.strokeStyle = '#29b6f6';
    CTX.lineWidth = 5;
    CTX.beginPath();
    CTX.arc(CONFIG.mapWidth/2, CONFIG.mapHeight/2, 100, 0, Math.PI*2);
    CTX.stroke();

    // Draw Gems
    gems.forEach(g => g.draw(CTX));

    // Draw Brawlers
    brawlers.forEach(b => {
        if (b.dead) return;

        // Shadow
        CTX.fillStyle = 'rgba(0,0,0,0.5)';
        CTX.beginPath();
        CTX.ellipse(b.pos.x, b.pos.y + 15, 20, 10, 0, 0, Math.PI*2);
        CTX.fill();

        // Body
        CTX.fillStyle = b.color;
        CTX.beginPath();
        CTX.arc(b.pos.x, b.pos.y, b.radius, 0, Math.PI*2);
        CTX.fill();
        CTX.lineWidth = 4;
        CTX.strokeStyle = '#000';
        CTX.stroke();

        // Aim indicator (if player)
        if (b === player && inputs.aim.mag() > 0.1) {
            CTX.save();
            CTX.translate(b.pos.x, b.pos.y);
            CTX.rotate(Math.atan2(inputs.aim.y, inputs.aim.x));
            CTX.fillStyle = 'rgba(255, 255, 255, 0.3)';
            CTX.fillRect(0, -5, b.range, 10);
            CTX.restore();
        }

        // HP Bar
        const hpPct = b.hp / b.maxHp;
        CTX.fillStyle = '#333';
        CTX.fillRect(b.pos.x - 25, b.pos.y - 50, 50, 8);
        CTX.fillStyle = '#00E676';
        CTX.fillRect(b.pos.x - 25, b.pos.y - 50, 50 * hpPct, 8);

        // Gem Count
        if (b.gems > 0) {
            CTX.font = "bold 16px Rubik";
            CTX.fillStyle = "#fff";
            CTX.textAlign = "center";
            CTX.fillText("üíé" + b.gems, b.pos.x, b.pos.y - 60);
        }
    });

    // Draw Projectiles
    projectiles.forEach(p => {
        CTX.fillStyle = p.team === 'blue' ? '#80d8ff' : '#ff8a80';
        CTX.beginPath();
        CTX.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI*2);
        CTX.fill();
    });

    // Draw Particles
    particles.forEach(p => p.draw(CTX));

    CTX.restore();
}

window.onload = initGame;
window.onresize = () => {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
};

</script>
</body>
</html>
