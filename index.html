<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Royale - „Ç∏„Çß„É†„Éª„É≠„ÉØ„Ç§„É§„É´</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+P+One&family=Noto+Sans+JP:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #FFC107;
            --blue-team: #007BFF;
            --red-team: #FF3B30;
            --header-font: 'Mochiy Pop P One', sans-serif;
            --body-font: 'Noto Sans JP', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            background-color: #121212;
            overflow: hidden;
            font-family: var(--body-font);
            color: white;
            height: 100vh;
            width: 100vw;
        }

        /* --- UI LAYERS --- */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-family: var(--header-font);
            font-size: 3.5rem;
            color: var(--primary);
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-align: center;
            line-height: 1.2;
        }

        /* „Ç≠„É£„É©ÈÅ∏Êäû„Ç´„Éº„Éâ */
        .card-container {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .char-card {
            background: #2c2c2c;
            border: 3px solid #555;
            border-radius: 15px;
            padding: 15px;
            width: 140px;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
            overflow: hidden;
        }
        /* „ÉÜ„ÇØ„Çπ„ÉÅ„É£È¢®„Éë„Çø„Éº„É≥ */
        .char-card::before {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            background-image: radial-gradient(#ffffff 1px, transparent 1px);
            background-size: 10px 10px;
            opacity: 0.05;
        }

        .char-card:hover, .char-card.selected {
            transform: translateY(-5px);
            border-color: var(--primary);
            background: #3e3e3e;
            box-shadow: 0 0 15px var(--primary);
        }

        .char-icon { font-size: 2.5rem; margin-bottom: 5px; }
        .char-name { font-family: var(--header-font); font-size: 1.2rem; color: #fff; }
        .char-role { font-size: 0.75rem; color: #aaa; margin-bottom: 8px; }

        .btn-start {
            font-family: var(--header-font);
            font-size: 1.8rem;
            background: linear-gradient(to bottom, #FFC107, #FF8F00);
            color: #000;
            border: none;
            padding: 12px 50px;
            border-radius: 50px;
            border-bottom: 6px solid #E65100;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        .btn-start:active { transform: translateY(4px); border-bottom-width: 2px; }

        /* --- HUD --- */
        .score-board {
            position: absolute;
            top: 15px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-family: var(--header-font);
            font-size: 2rem;
            text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.5);
            padding: 5px 20px;
            border-radius: 30px;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 20;
        }
        .score-blue { color: #4fc3f7; }
        .score-red { color: #ff8a80; }

        /* Âæ©Ê¥ª„Çø„Ç§„Éû„Éº */
        #respawn-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* ‰∏ã„ÅÆÊìç‰Ωú„ÇíÈÇ™È≠î„Åó„Å™„ÅÑÔºàÊìç‰Ωú‰∏çËÉΩ„Å´„Åô„Çã„Å™„ÇâautoÔºâ */
            z-index: 50;
        }
        .respawn-text {
            font-family: var(--header-font);
            font-size: 4rem;
            color: #ff5252;
            text-shadow: 3px 3px 0 #000;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* „É™„Ç∂„É´„ÉàÁîªÈù¢ */
        .stats-table {
            width: 90%;
            max-width: 600px;
            margin: 20px 0;
            border-collapse: collapse;
            font-size: 1rem;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
        }
        .stats-table th, .stats-table td {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #444;
        }
        .stats-table th { background: #333; color: #aaa; }
        .row-blue { color: #4fc3f7; }
        .row-red { color: #ff8a80; }
        .me-indicator { border: 1px solid #FFC107; padding: 2px 5px; border-radius: 4px; font-size: 0.8rem; color: #FFC107; margin-left:5px;}

        /* JoySticks */
        .joystick-zone { position: absolute; bottom: 30px; width: 140px; height: 140px; pointer-events: auto; z-index: 30; }
        #stick-left { left: 30px; }
        #stick-right { right: 30px; }
        .joystick-base {
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            position: relative;
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }
        .joystick-handle {
            width: 50px; height: 50px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #stick-right .joystick-handle { background: rgba(255, 82, 82, 0.8); }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="hud" class="hidden">
            <div class="score-board">
                <div class="score-blue"><span id="score-blue-val">0</span> üíé</div>
                <div style="color:white; font-size:1.5rem;">:</div>
                <div class="score-red">üíé <span id="score-red-val">0</span></div>
            </div>
            
            <div id="respawn-overlay" class="hidden">
                <div class="respawn-text">Âæ©Ê¥ª„Åæ„Åß <span id="respawn-timer">3</span></div>
            </div>

            <div id="stick-left" class="joystick-zone">
                <div class="joystick-base"><div class="joystick-handle"></div></div>
            </div>
            <div id="stick-right" class="joystick-zone">
                <div class="joystick-base"><div class="joystick-handle"></div></div>
            </div>
        </div>

        <div id="main-menu" class="overlay">
            <h1>GEM ROYALE<br><span style="font-size:1.5rem; color:white;">„Ç∏„Çß„É†„Éª„É≠„ÉØ„Ç§„É§„É´</span></h1>
            
            <div class="card-container">
                <div class="char-card selected" onclick="selectChar('fighter', this)">
                    <div class="char-icon">ü§†</div>
                    <div class="char-name">„Éï„Ç°„Ç§„Çø„Éº</div>
                    <div class="char-role">ËøëË∑ùÈõ¢ / „Éê„É©„É≥„Çπ</div>
                </div>
                <div class="char-card" onclick="selectChar('sniper', this)">
                    <div class="char-icon">üëÆ</div>
                    <div class="char-name">„Çπ„Éä„Ç§„Éë„Éº</div>
                    <div class="char-role">ÈÅ†Ë∑ùÈõ¢ / È´òÁÅ´Âäõ</div>
                </div>
                <div class="char-card" onclick="selectChar('tank', this)">
                    <div class="char-icon">ü§º</div>
                    <div class="char-name">„Çø„É≥„ÇØ</div>
                    <div class="char-role">Ë∂ÖËøëÊé• / È´òËÄê‰πÖ</div>
                </div>
            </div>

            <button class="btn-start" onclick="startGame()">BATTLE START</button>
            <p style="margin-top:15px; color:#888; font-size:0.8rem;">‚ÄªÈü≥„ÅåÂá∫„Åæ„Åô</p>
        </div>

        <div id="result-screen" class="overlay hidden">
            <h2 id="result-title" style="font-family: var(--header-font); font-size: 4rem; margin: 0;">VICTORY!</h2>
            
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>ÂêçÂâç</th>
                        <th>„Ç≠„É´</th>
                        <th>„Éá„Çπ</th>
                        <th>„Ç∏„Çß„É†</th>
                    </tr>
                </thead>
                <tbody id="stats-body">
                    </tbody>
            </table>

            <button class="btn-start" onclick="resetGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        </div>
    </div>

<script>
/**
 * ----------------------------------------------------
 * AUDIO MANAGER (Web Audio API - No external files)
 * ----------------------------------------------------
 */
class AudioManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.bgmOsc = null;
        this.bgmGain = null;
        this.isPlaying = false;
    }

    resume() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, vol = 0.1) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playShoot(type) {
        // „Éî„É•„É≥ÔºÅ
        if (type === 'sniper') this.playTone(600, 'square', 0.1, 0.05);
        else if (type === 'tank') this.playTone(150, 'sawtooth', 0.2, 0.1);
        else this.playTone(400, 'triangle', 0.1, 0.05);
    }

    playHit() {
        // „Éú„Çπ„ÉÉ
        this.playTone(100, 'sawtooth', 0.1, 0.05);
    }

    playGem() {
        // „Ç≠„É©„ÉÉ
        this.playTone(1200, 'sine', 0.2, 0.1);
        setTimeout(() => this.playTone(1800, 'sine', 0.3, 0.1), 100);
    }

    playDie() {
        // „Éì„Éß„Éº„É≥
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }

    startBGM() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        // Simple Drum Loop
        this.beatInterval = setInterval(() => {
            if(!gameActive) return;
            // Kick
            this.playTone(80, 'sine', 0.1, 0.3);
            // Hat
            setTimeout(() => this.playTone(1200, 'square', 0.05, 0.02), 250);
            setTimeout(() => this.playTone(1200, 'square', 0.05, 0.02), 750);
            // Snare
            setTimeout(() => this.playTone(200, 'sawtooth', 0.1, 0.1), 500);
        }, 1000);
    }
}

const Audio = new AudioManager();

/**
 * ----------------------------------------------------
 * GRAPHICS GENERATOR (Procedural Textures)
 * ----------------------------------------------------
 */
function createPattern(color1, color2, size=32) {
    const pCanvas = document.createElement('canvas');
    pCanvas.width = size;
    pCanvas.height = size;
    const pCtx = pCanvas.getContext('2d');
    
    // Base
    pCtx.fillStyle = color1;
    pCtx.fillRect(0,0,size,size);
    
    // Noise/Texture
    pCtx.fillStyle = color2;
    pCtx.globalAlpha = 0.1;
    for(let i=0; i<10; i++) {
        pCtx.fillRect(Math.random()*size, Math.random()*size, 4, 4);
    }
    // Checker hint
    pCtx.fillStyle = 'rgba(0,0,0,0.05)';
    pCtx.fillRect(0,0,size/2,size/2);
    pCtx.fillRect(size/2,size/2,size/2,size/2);

    return CTX.createPattern(pCanvas, 'repeat');
}


/**
 * ----------------------------------------------------
 * GAME ENGINE
 * ----------------------------------------------------
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

const CONFIG = {
    mapWidth: 1800,
    mapHeight: 1800,
    tileSize: 150,
    gemSpawnRate: 200,
    cameraScale: 0.65, // Êà¶Ê≥Å„ÇíË¶ã„ÇÑ„Åô„Åè„Åô„Çã„Åü„ÇÅ„Å´„Ç∫„Éº„É†„Ç¢„Ç¶„Éà
};

let gameActive = false;
let camera = { x: 0, y: 0 };
let playerType = 'fighter';
let floorPattern;

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m);
    }
}

class Entity {
    constructor(x, y, radius) {
        this.pos = new Vector(x, y);
        this.radius = radius;
        this.dead = false;
    }
}

class Brawler extends Entity {
    constructor(x, y, team, type, isBot = false, name) {
        super(x, y, 40);
        this.team = team;
        this.type = type;
        this.isBot = isBot;
        this.name = name;
        this.velocity = new Vector(0, 0);
        this.respawnTimer = 0;
        
        // Stats for result
        this.stats = { kills: 0, deaths: 0, gems: 0 };

        // Configuration
        if (type === 'tank') {
            this.maxHp = 6000; this.speed = 5; this.range = 180;
            this.damage = 1000; this.reloadTime = 40;
            this.color = team==='blue' ? '#2979FF' : '#FF1744';
            this.isMelee = true;
        } else if (type === 'sniper') {
            this.maxHp = 2800; this.speed = 6; this.range = 900;
            this.damage = 900; this.reloadTime = 35;
            this.color = team==='blue' ? '#40C4FF' : '#FF5252';
            this.isMelee = false;
        } else {
            this.maxHp = 4200; this.speed = 5.5; this.range = 450;
            this.damage = 400; this.reloadTime = 45;
            this.color = team==='blue' ? '#00B0FF' : '#D50000';
            this.isMelee = false;
            this.projectileCount = 3; // Shotgun
        }
        
        this.hp = this.maxHp;
        this.currentGemCount = 0;
        this.cooldown = 0;
        this.target = null;
    }

    update() {
        if (this.dead) {
            this.respawnTimer--;
            if (this === player) {
                document.getElementById('respawn-timer').innerText = Math.ceil(this.respawnTimer / 60);
            }
            if (this.respawnTimer <= 0) this.respawn();
            return;
        }

        this.velocity = this.velocity.mult(0.85); // Friction
        this.pos = this.pos.add(this.velocity);
        if (this.cooldown > 0) this.cooldown--;

        // Map Bounds
        this.pos.x = Math.max(this.radius, Math.min(CONFIG.mapWidth - this.radius, this.pos.x));
        this.pos.y = Math.max(this.radius, Math.min(CONFIG.mapHeight - this.radius, this.pos.y));

        if (this.isBot) this.updateAI();
    }

    shoot(aimVector) {
        if (this.dead || this.cooldown > 0) return;
        this.cooldown = this.reloadTime;
        Audio.playShoot(this.type);

        if (this.isMelee) {
            // Melee
            particles.push(new Particle(this.pos.x + aimVector.x*50, this.pos.y + aimVector.y*50, 80, '#fff', 10));
            brawlers.forEach(b => {
                if (b.team !== this.team && !b.dead) {
                    if (b.pos.sub(this.pos).mag() < this.range) {
                        b.takeDamage(this.damage, this);
                    }
                }
            });
        } else {
            // Ranged
            const count = this.type === 'fighter' ? 3 : 1;
            const spread = this.type === 'fighter' ? 0.3 : 0;
            const speed = 25;
            
            let baseAngle = Math.atan2(aimVector.y, aimVector.x);
            let startAngle = baseAngle - spread/2;
            
            for(let i=0; i<count; i++) {
                let angle = startAngle + (count > 1 ? (spread/(count-1))*i : 0);
                let vel = new Vector(Math.cos(angle)*speed, Math.sin(angle)*speed);
                projectiles.push(new Projectile(this.pos.x, this.pos.y, vel, this.damage, this.team, this.range, this));
            }
        }
    }

    takeDamage(amount, attacker) {
        if (this.dead) return;
        this.hp -= amount;
        spawnFloatingText(Math.floor(amount), this.pos.x, this.pos.y - 40, '#fff');
        Audio.playHit();
        
        if (this.hp <= 0) {
            this.die(attacker);
        }
    }

    die(attacker) {
        this.dead = true;
        this.respawnTimer = 180; // 3 sec (60fps)
        this.stats.deaths++;
        if (attacker) attacker.stats.kills++;
        
        Audio.playDie();
        
        // Drop gems
        let gemsToDrop = Math.floor(this.currentGemCount / 2) + 2;
        this.currentGemCount = 0;
        for(let i=0; i<gemsToDrop; i++) {
            gems.push(new Gem(this.pos.x + (Math.random()*60-30), this.pos.y + (Math.random()*60-30)));
        }
        
        spawnFloatingText("DOWN!", this.pos.x, this.pos.y, 'red');

        // Show UI if player
        if (this === player) {
            document.getElementById('respawn-overlay').classList.remove('hidden');
        }
    }

    respawn() {
        this.dead = false;
        this.hp = this.maxHp;
        // Base Spawn
        this.pos = this.team === 'blue' 
            ? new Vector(150, CONFIG.mapHeight/2 + Math.random()*200-100)
            : new Vector(CONFIG.mapWidth-150, CONFIG.mapHeight/2 + Math.random()*200-100);
        
        spawnFloatingText("REVIVE!", this.pos.x, this.pos.y, '#00E676');
        
        if (this === player) {
            document.getElementById('respawn-overlay').classList.add('hidden');
        }
    }

    updateAI() {
        // Simple Logic: Find nearest gem or enemy
        let target = null;
        let mode = 'hunt'; // hunt, flee, collect

        // Look for gems first
        let nearestGem = null;
        let minGemDist = 9999;
        gems.forEach(g => {
            let d = this.pos.sub(g.pos).mag();
            if (d < minGemDist) { minGemDist = d; nearestGem = g; }
        });

        if (nearestGem && this.currentGemCount < 8 && minGemDist < 600) {
            target = nearestGem.pos;
            mode = 'collect';
        } else {
            // Find enemy
            let nearestEnemy = null;
            let minEnemyDist = 9999;
            brawlers.forEach(b => {
                if (b.team !== this.team && !b.dead) {
                    let d = this.pos.sub(b.pos).mag();
                    if (d < minEnemyDist) { minEnemyDist = d; nearestEnemy = b; }
                }
            });
            if (nearestEnemy) {
                target = nearestEnemy.pos;
                // If I have many gems or low HP, flee
                if (this.currentGemCount > 8 || this.hp < this.maxHp * 0.3) mode = 'flee';
            }
        }

        if (target) {
            let dir = target.sub(this.pos).normalize();
            if (mode === 'flee') dir = dir.mult(-1);
            
            // Movement
            this.velocity = this.velocity.add(dir.mult(0.6));
            if (this.velocity.mag() > this.speed) this.velocity = this.velocity.normalize().mult(this.speed);

            // Shooting
            if (mode !== 'collect' && mode !== 'flee' && Math.random() < 0.05) {
                 this.shoot(target.sub(this.pos));
            }
        } else {
            // Go center
            let center = new Vector(CONFIG.mapWidth/2, CONFIG.mapHeight/2);
            this.velocity = this.velocity.add(center.sub(this.pos).normalize().mult(0.3));
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, vel, damage, team, range, owner) {
        super(x, y, 12);
        this.velocity = vel;
        this.damage = damage;
        this.team = team;
        this.maxDist = range;
        this.dist = 0;
        this.owner = owner;
    }
    update() {
        this.pos = this.pos.add(this.velocity);
        this.dist += this.velocity.mag();
        if (this.dist >= this.maxDist) this.dead = true;

        brawlers.forEach(b => {
            if (b.team !== this.team && !b.dead) {
                if (b.pos.sub(this.pos).mag() < b.radius + this.radius) {
                    b.takeDamage(this.damage, this.owner);
                    this.dead = true;
                    // Spark effect
                    for(let i=0;i<4;i++) particles.push(new Particle(this.pos.x, this.pos.y, 6, this.team==='blue'?'#80D8FF':'#FF8A80', 10));
                }
            }
        });
    }
}

class Gem extends Entity {
    constructor(x, y) {
        super(x, y, 15);
        this.floatY = 0;
    }
    update() {
        this.floatY = Math.sin(Date.now()/300)*5;
        brawlers.forEach(b => {
            if (!b.dead && b.pos.sub(this.pos).mag() < b.radius + this.radius) {
                this.dead = true;
                b.currentGemCount++;
                b.stats.gems++;
                Audio.playGem();
                spawnFloatingText("+1", b.pos.x, b.pos.y-50, '#D500F9');
            }
        });
    }
    draw() {
        CTX.fillStyle = '#D500F9';
        CTX.beginPath();
        CTX.moveTo(this.pos.x, this.pos.y - 12 + this.floatY);
        CTX.lineTo(this.pos.x+12, this.pos.y + this.floatY);
        CTX.lineTo(this.pos.x, this.pos.y + 12 + this.floatY);
        CTX.lineTo(this.pos.x-12, this.pos.y + this.floatY);
        CTX.fill();
        // Shine
        CTX.fillStyle = '#fff';
        CTX.beginPath();
        CTX.arc(this.pos.x-4, this.pos.y-4+this.floatY, 3, 0, Math.PI*2);
        CTX.fill();
    }
}

class Particle extends Entity {
    constructor(x, y, size, color, life) {
        super(x, y, size);
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.velocity = new Vector((Math.random()-0.5)*10, (Math.random()-0.5)*10);
    }
    update() {
        this.pos = this.pos.add(this.velocity);
        this.life--;
        if (this.life<=0) this.dead=true;
    }
}

let brawlers = [], projectiles = [], gems = [], particles = [];
let player;
const inputs = { move: new Vector(0,0), aim: new Vector(0,0) };

function init() {
    setupJoystick('stick-left', 'move');
    setupJoystick('stick-right', 'aim');
    resize();
    floorPattern = createPattern('#2c2b30', '#35343a', CONFIG.tileSize);
    loop();
}

function selectChar(type, el) {
    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
    playerType = type;
}

function startGame() {
    Audio.resume();
    Audio.startBGM();
    
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');

    brawlers = []; projectiles = []; gems = []; particles = [];
    
    // Player
    player = new Brawler(200, CONFIG.mapHeight/2, 'blue', playerType, false, "„ÅÇ„Å™„Åü");
    brawlers.push(player);
    // Blue Bots
    brawlers.push(new Brawler(200, CONFIG.mapHeight/2-300, 'blue', 'sniper', true, "Âë≥ÊñπA"));
    brawlers.push(new Brawler(200, CONFIG.mapHeight/2+300, 'blue', 'tank', true, "Âë≥ÊñπB"));
    // Red Bots
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2, 'red', 'fighter', true, "ÊïµA"));
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2-300, 'red', 'sniper', true, "ÊïµB"));
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2+300, 'red', 'tank', true, "ÊïµC"));

    gameActive = true;
}

function resetGame() {
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('main-menu').classList.remove('hidden');
}

function spawnFloatingText(text, x, y, color) {
    const el = document.createElement('div');
    el.innerText = text;
    el.style.position = 'absolute';
    el.style.left = '50%';
    el.style.top = '50%';
    el.style.transform = `translate(-50%, -50%)`;
    el.style.color = color;
    el.style.fontFamily = 'var(--header-font)';
    el.style.fontWeight = 'bold';
    el.style.fontSize = '1.5rem';
    el.style.textShadow = '2px 2px 0 #000';
    el.style.pointerEvents = 'none';
    el.style.transition = 'all 0.8s ease-out';
    
    // Convert World Pos to Screen Pos logic roughly handled by inline style update in loop? 
    // Simplified: Just use DOM overlay, but we need to track World Pos.
    // Easier approach: Add to a JS array and draw on Canvas to sync with camera.
    particles.push({
        text: text, x: x, y: y, color: color, life: 60, isText: true
    });
}

function endGame(winner) {
    gameActive = false;
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('respawn-overlay').classList.add('hidden');
    
    const screen = document.getElementById('result-screen');
    const title = document.getElementById('result-title');
    screen.classList.remove('hidden');

    if (winner === 'blue') {
        title.innerText = "VICTORY!";
        title.style.color = "#00E676";
    } else {
        title.innerText = "DEFEAT...";
        title.style.color = "#FF1744";
    }

    // Populate Stats
    const tbody = document.getElementById('stats-body');
    tbody.innerHTML = '';
    brawlers.sort((a,b) => b.stats.kills - a.stats.kills).forEach(b => {
        const tr = document.createElement('tr');
        tr.className = b.team === 'blue' ? 'row-blue' : 'row-red';
        let name = b.name;
        if(b === player) name += " <span class='me-indicator'>YOU</span>";
        
        tr.innerHTML = `
            <td style="text-align:left; padding-left:20px;">${name}</td>
            <td>${b.stats.kills}</td>
            <td>${b.stats.deaths}</td>
            <td>${b.stats.gems}</td>
        `;
        tbody.appendChild(tr);
    });
}

function loop() {
    requestAnimationFrame(loop);
    
    // Background Fill
    CTX.fillStyle = '#111';
    CTX.fillRect(0,0, CANVAS.width, CANVAS.height);

    if (!gameActive) return;

    // --- LOGIC ---
    if (Math.random() < 0.02 && gems.length < 20) {
        gems.push(new Gem(CONFIG.mapWidth/2 + (Math.random()*150-75), CONFIG.mapHeight/2 + (Math.random()*150-75)));
    }

    // Player Move
    if (inputs.move.mag() > 0.1 && !player.dead) {
        player.velocity = player.velocity.add(inputs.move.mult(0.9));
        if (player.velocity.mag() > player.speed) player.velocity = player.velocity.normalize().mult(player.speed);
    }

    [...brawlers, ...projectiles, ...gems, ...particles].forEach(e => {
        if (!e.isText) e.update();
        else e.life--;
    });

    // Score Check
    let blueScore = brawlers.filter(b=>b.team==='blue').reduce((a,c)=>a+c.currentGemCount,0);
    let redScore = brawlers.filter(b=>b.team==='red').reduce((a,c)=>a+c.currentGemCount,0);
    document.getElementById('score-blue-val').innerText = blueScore;
    document.getElementById('score-red-val').innerText = redScore;

    if (blueScore >= 10 && blueScore > redScore) setTimeout(()=>endGame('blue'), 1000);
    if (redScore >= 10 && redScore > blueScore) setTimeout(()=>endGame('red'), 1000);

    // Cleanup
    projectiles = projectiles.filter(p=>!p.dead);
    gems = gems.filter(g=>!g.dead);
    particles = particles.filter(p=>!p.dead && p.life > 0);

    // Camera
    let targetX = player.pos.x;
    let targetY = player.pos.y;
    camera.x += (targetX - camera.x) * 0.1;
    camera.y += (targetY - camera.y) * 0.1;

    // --- DRAWING ---
    CTX.save();
    
    // Camera Transform (Zoomed Out)
    CTX.translate(CANVAS.width/2, CANVAS.height/2);
    CTX.scale(CONFIG.cameraScale, CONFIG.cameraScale);
    CTX.translate(-camera.x, -camera.y);

    // Draw Floor Texture
    CTX.fillStyle = floorPattern;
    CTX.fillRect(0, 0, CONFIG.mapWidth, CONFIG.mapHeight);
    
    // Map Border
    CTX.strokeStyle = '#555';
    CTX.lineWidth = 10;
    CTX.strokeRect(0,0,CONFIG.mapWidth, CONFIG.mapHeight);

    // Center Mine
    CTX.beginPath();
    CTX.arc(CONFIG.mapWidth/2, CONFIG.mapHeight/2, 120, 0, Math.PI*2);
    CTX.fillStyle = 'rgba(0,0,0,0.3)';
    CTX.fill();
    CTX.strokeStyle = '#D500F9';
    CTX.lineWidth = 4;
    CTX.setLineDash([10, 10]);
    CTX.stroke();
    CTX.setLineDash([]);

    gems.forEach(g => g.draw());

    brawlers.forEach(b => {
        if (b.dead) return;
        
        // Shadow
        CTX.fillStyle = 'rgba(0,0,0,0.4)';
        CTX.beginPath();
        CTX.ellipse(b.pos.x, b.pos.y+10, b.radius*0.8, b.radius*0.4, 0, 0, Math.PI*2);
        CTX.fill();

        // Unit
        CTX.fillStyle = b.color;
        CTX.beginPath();
        CTX.arc(b.pos.x, b.pos.y, b.radius, 0, Math.PI*2);
        CTX.fill();
        
        // Texture overlay on unit
        CTX.fillStyle = 'rgba(255,255,255,0.1)';
        CTX.beginPath();
        CTX.arc(b.pos.x-10, b.pos.y-10, b.radius/2, 0, Math.PI*2);
        CTX.fill();

        // Stroke
        CTX.strokeStyle = '#fff';
        CTX.lineWidth = 3;
        CTX.stroke();

        // Aim Guide
        if (b === player && inputs.aim.mag() > 0.1) {
            CTX.save();
            CTX.translate(b.pos.x, b.pos.y);
            CTX.rotate(Math.atan2(inputs.aim.y, inputs.aim.x));
            CTX.fillStyle = 'rgba(255,255,255,0.2)';
            CTX.beginPath();
            if (b.type==='fighter') {
                CTX.moveTo(0,0); CTX.lineTo(b.range, -60); CTX.lineTo(b.range, 60);
            } else {
                CTX.fillRect(0, -10, b.range, 20);
            }
            CTX.fill();
            CTX.restore();
        }

        // HP Bar
        const pct = b.hp / b.maxHp;
        CTX.fillStyle = '#222';
        CTX.fillRect(b.pos.x - 30, b.pos.y - 60, 60, 10);
        CTX.fillStyle = pct > 0.5 ? '#00E676' : '#FF1744';
        CTX.fillRect(b.pos.x - 30, b.pos.y - 60, 60*pct, 10);
        
        // Name
        CTX.fillStyle = '#fff';
        CTX.font = "bold 20px 'Noto Sans JP'";
        CTX.textAlign = 'center';
        CTX.fillText(b.name, b.pos.x, b.pos.y - 70);

        if (b.currentGemCount > 0) {
            CTX.font = "24px sans-serif";
            CTX.fillText("üíé"+b.currentGemCount, b.pos.x, b.pos.y - 90);
        }
    });

    projectiles.forEach(p => {
        CTX.fillStyle = p.team === 'blue' ? '#80D8FF' : '#FF8A80';
        CTX.beginPath();
        CTX.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI*2);
        CTX.fill();
    });

    // Particles / Floating Text
    particles.forEach(p => {
        if (p.isText) {
            CTX.font = "bold 32px 'Mochiy Pop P One'";
            CTX.fillStyle = p.color;
            CTX.strokeStyle = 'black';
            CTX.lineWidth = 4;
            CTX.strokeText(p.text, p.x, p.y - (60-p.life));
            CTX.fillText(p.text, p.x, p.y - (60-p.life));
        } else {
            CTX.fillStyle = p.color;
            CTX.globalAlpha = p.life/p.maxLife;
            CTX.beginPath();
            CTX.arc(p.pos.x, p.pos.y, p.radius * (p.life/p.maxLife), 0, Math.PI*2);
            CTX.fill();
            CTX.globalAlpha = 1;
        }
    });

    CTX.restore();
}

function resize() {
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;
}

// Input Helpers
function setupJoystick(id, type) {
    const zone = document.getElementById(id);
    const handle = zone.querySelector('.joystick-handle');
    let touchId = null, origin = {x:0, y:0};

    const handleStart = (e) => {
        e.preventDefault();
        const t = e.changedTouches ? e.changedTouches[0] : e;
        if(e.changedTouches) touchId = t.identifier;
        const r = zone.getBoundingClientRect();
        origin = {x: r.left+r.width/2, y: r.top+r.height/2};
        update(t.clientX, t.clientY);
    };
    const handleMove = (e) => {
        e.preventDefault();
        const t = e.changedTouches ? [...e.changedTouches].find(touch=>touch.identifier===touchId) : e;
        if(t) update(t.clientX, t.clientY);
    };
    const handleEnd = (e) => {
        e.preventDefault();
        touchId = null;
        handle.style.transform = `translate(-50%, -50%)`;
        if (type==='move') inputs.move = new Vector(0,0);
        else {
            if(inputs.aim.mag() > 0.2) player.shoot(inputs.aim);
            inputs.aim = new Vector(0,0);
        }
    };
    function update(cx, cy) {
        let dx = cx - origin.x, dy = cy - origin.y;
        let dist = Math.sqrt(dx*dx+dy*dy), angle = Math.atan2(dy,dx);
        let max = 50;
        if(dist>max) { dx = Math.cos(angle)*max; dy=Math.sin(angle)*max; }
        handle.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        let v = new Vector(dx/max, dy/max);
        if(type==='move') inputs.move = v; else inputs.aim = v;
    }
    zone.addEventListener('touchstart', handleStart, {passive:false});
    zone.addEventListener('touchmove', handleMove, {passive:false});
    zone.addEventListener('touchend', handleEnd, {passive:false});
    zone.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', e => { if(touchId!==null && !e.changedTouches) handleMove(e); });
    window.addEventListener('mouseup', e => { if(touchId!==null && !e.changedTouches) handleEnd(e); });
}

window.addEventListener('resize', resize);
window.onload = init;

</script>
</body>
</html>
