<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Royale - Ultimate</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chango&family=M+PLUS+Rounded+1c:wght@500;800&family=Fredoka:wght@600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #FFC107;
            --secondary: #FF9800;
            --blue-team: #2196F3;
            --red-team: #E91E63;
            --font-title: 'Chango', cursive;
            --font-ui: 'Fredoka', sans-serif;
            --font-jp: 'M PLUS Rounded 1c', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
            font-family: var(--font-jp);
            color: white;
            height: 100vh;
            width: 100vw;
        }

        /* „Ç≤„Éº„É†„Ç≠„É£„É≥„Éê„Çπ */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- ÂÖ±ÈÄö„Ç™„Éº„Éê„Éº„É¨„Ç§ --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: all 0.3s ease;
        }
        .hidden { opacity: 0; pointer-events: none; }

        /* --- UI „Éá„Ç∂„Ç§„É≥ (Brawl Stars Style) --- */
        h1 {
            font-family: var(--font-title);
            font-size: 3.5rem;
            color: #FFEB3B;
            -webkit-text-stroke: 3px #3E2723;
            text-shadow: 0 8px 0 #3E2723;
            transform: rotate(-3deg);
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        /* „Ç≠„É£„É©„ÇØ„Çø„Éº„Ç´„Éº„Éâ */
        .card-container {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .char-card {
            background: linear-gradient(145deg, #424242, #303030);
            border: 4px solid #616161;
            border-radius: 20px;
            padding: 15px;
            width: 140px;
            text-align: center;
            cursor: pointer;
            transition: 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 0 #212121;
        }
        .char-card.selected {
            background: linear-gradient(145deg, #FFF176, #FDD835);
            border-color: #fff;
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 15px 0 #F57F17;
        }
        .char-card.selected .char-name { color: #3E2723; }
        .char-card.selected .char-icon { transform: scale(1.2); }
        
        .char-icon { font-size: 3rem; margin-bottom: 5px; transition: 0.2s; }
        .char-name { font-family: var(--font-ui); font-weight: 800; font-size: 1.1rem; color: #fff; }

        /* „Çπ„Çø„Éº„Éà„Éú„Çø„É≥ */
        .btn-start {
            font-family: var(--font-title);
            font-size: 2rem;
            background: #FFC107;
            color: #3E2723;
            border: 4px solid #fff;
            padding: 15px 60px;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 10px 0 #F57F17, 0 20px 20px rgba(0,0,0,0.4);
            transition: 0.1s;
            text-transform: uppercase;
        }
        .btn-start:active { transform: translateY(8px); box-shadow: 0 2px 0 #F57F17; }

        /* --- HUD (Êà¶ÈóòÁîªÈù¢) --- */
        #hud { pointer-events: none; }
        
        /* „Çπ„Ç≥„Ç¢„Éú„Éº„Éâ */
        .score-board {
            position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; justify-content: space-between;
            width: 320px; height: 60px;
            background: rgba(0,0,0,0.5);
            border-radius: 30px;
            padding: 0 10px;
            border: 3px solid rgba(255,255,255,0.2);
        }
        .team-score {
            display: flex; align-items: center; gap: 10px;
            font-family: var(--font-title); font-size: 2rem;
            -webkit-text-stroke: 1.5px black;
        }
        .score-blue { color: #40C4FF; }
        .score-red { color: #FF4081; flex-direction: row-reverse; }
        .timer-display {
            font-family: var(--font-ui); font-weight: bold; font-size: 1.2rem;
            color: #ddd; background: #333; padding: 5px 15px; border-radius: 20px;
        }

        /* „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ */
        #countdown-container {
            position: absolute; top: 15%; width: 100%;
            text-align: center; display: none;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        
        .cd-title { font-family: var(--font-jp); font-weight: 800; font-size: 1.5rem; color: #fff; text-shadow: 2px 2px 0 #000; margin-bottom: 5px; }
        .cd-number {
            font-family: var(--font-title); font-size: 6rem;
            -webkit-text-stroke: 3px black;
            animation: pulse 1s infinite;
        }
        .cd-blue { color: #40C4FF; text-shadow: 0 10px 0 #0277BD; }
        .cd-red { color: #FF4081; text-shadow: 0 10px 0 #C2185B; }

        /* Âæ©Ê¥ª„Çø„Ç§„Éû„Éº */
        #respawn-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50;
        }
        .respawn-box {
            background: #212121; border: 4px solid #757575; border-radius: 20px;
            padding: 20px 40px; text-align: center;
            box-shadow: 0 15px 30px rgba(0,0,0,0.5);
        }

        /* „É™„Ç∂„É´„ÉàÁîªÈù¢ */
        .result-header { font-family: var(--font-title); font-size: 4rem; margin: 0; -webkit-text-stroke: 2px black; }
        .win { color: #00E676; text-shadow: 0 10px 0 #1B5E20; }
        .lose { color: #FF5252; text-shadow: 0 10px 0 #B71C1C; }
        
        .stats-table {
            width: 100%; max-width: 600px; margin: 20px 0;
            background: #fff; border-radius: 10px; overflow: hidden;
            box-shadow: 0 10px 0 #ccc;
            font-family: var(--font-ui); color: #333;
            border-collapse: collapse;
        }
        .stats-table th { background: #eee; padding: 10px; font-weight: 800; color: #555; }
        .stats-table td { padding: 10px; text-align: center; border-bottom: 2px solid #eee; font-weight: 700; font-size: 1.2rem; }
        .stats-table .mvp { background: #FFF9C4; } /* MVP highlight */
        .me-badge { background: #FFC107; color: #3E2723; padding: 2px 6px; border-radius: 5px; font-size: 0.8rem; margin-left: 5px; }

        /* „Ç≥„É≥„Éà„É≠„Éº„É©„Éº */
        .joystick-zone { position: absolute; bottom: 40px; width: 160px; height: 160px; pointer-events: auto; }
        #stick-left { left: 40px; }
        #stick-right { right: 40px; }
        .joystick-base {
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.2); border: 4px solid rgba(255,255,255,0.3); border-radius: 50%;
            position: relative;
        }
        .joystick-handle {
            width: 70px; height: 70px; border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 8px 15px rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.5);
        }
        #stick-left .joystick-handle { background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23007BFF"><path d="M12 2L15 8L21 9L16.5 13L18 19L12 16L6 19L7.5 13L3 9L9 8Z"/></svg>') center/40% no-repeat, #fff; }
        #stick-right .joystick-handle { background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FF3B30"><path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM11 7H13V11H17V13H13V17H11V13H7V11H11V7Z"/></svg>') center/50% no-repeat, #fff; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="hud" class="hidden">
        <div class="score-board">
            <div class="team-score score-blue"><span id="score-blue-val">0</span> üíé</div>
            <div class="timer-display" id="game-timer">00:00</div>
            <div class="team-score score-red">üíé <span id="score-red-val">0</span></div>
        </div>

        <div id="countdown-container">
            <div class="cd-title">Âà∂ÂúßÂÆå‰∫Ü„Åæ„Åß</div>
            <div id="countdown-number" class="cd-number cd-blue">10</div>
        </div>

        <div id="respawn-overlay" class="hidden">
            <div class="respawn-box">
                <div style="font-size:1.2rem; color:#aaa; margin-bottom:10px;">Âæ©Â∏∞„Åæ„Åß</div>
                <div id="respawn-timer" style="font-family:var(--font-title); font-size:4rem; color:#FFC107;">3</div>
            </div>
        </div>

        <div id="stick-left" class="joystick-zone"><div class="joystick-base"><div class="joystick-handle"></div></div></div>
        <div id="stick-right" class="joystick-zone"><div class="joystick-base"><div class="joystick-handle"></div></div></div>
    </div>

    <div id="main-menu" class="overlay">
        <h1>GEM BRAWL</h1>
        
        <div class="card-container">
            <div class="char-card selected" onclick="selectChar('fighter', this)">
                <div class="char-icon">ü§†</div>
                <div class="char-name">„Éï„Ç°„Ç§„Çø„Éº</div>
            </div>
            <div class="char-card" onclick="selectChar('sniper', this)">
                <div class="char-icon">üëÆ</div>
                <div class="char-name">„Çπ„Éä„Ç§„Éë„Éº</div>
            </div>
            <div class="char-card" onclick="selectChar('tank', this)">
                <div class="char-icon">ü§º</div>
                <div class="char-name">„Çø„É≥„ÇØ</div>
            </div>
        </div>

        <button class="btn-start" onclick="startGame()">BATTLE START</button>
    </div>

    <div id="result-screen" class="overlay hidden">
        <h2 id="result-title" class="result-header">VICTORY!</h2>
        <div style="margin-bottom:20px; font-size:1.5rem; font-weight:bold; color:#ddd;" id="mvp-text"></div>
        
        <table class="stats-table">
            <thead><tr><th>NAME</th><th>KILLS</th><th>DEATHS</th><th>GEMS</th></tr></thead>
            <tbody id="stats-body"></tbody>
        </table>

        <button class="btn-start" onclick="resetGame()">PLAY AGAIN</button>
    </div>
</div>

<script>
/** ---------------- AUDIO SYSTEM ---------------- */
class AudioManager {
    constructor() { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
    resume() { if(this.ctx.state==='suspended') this.ctx.resume(); }
    playTone(f,t,d,v=0.1,s=null) {
        const o=this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type=t; o.frequency.setValueAtTime(f,this.ctx.currentTime);
        if(s) o.frequency.linearRampToValueAtTime(s,this.ctx.currentTime+d);
        g.gain.setValueAtTime(v,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime+d);
    }
    shoot(type) { type==='sniper'?this.playTone(600,'square',0.15,0.1,300) : (type==='tank'?this.playTone(150,'sawtooth',0.2,0.15,50) : this.playTone(300,'triangle',0.1,0.1,100)); }
    hit() { this.playTone(100,'sawtooth',0.1,0.1); }
    gem() { this.playTone(1200,'sine',0.15,0.1,1800); setTimeout(()=>this.playTone(1800,'sine',0.2,0.1),100); }
    die() { this.playTone(400,'triangle',0.5,0.3,50); }
    count() { this.playTone(800,'square',0.05,0.1); }
}
const Audio = new AudioManager();

/** ---------------- UTILS ---------------- */
const Vector = {
    add: (v1,v2) => ({x:v1.x+v2.x, y:v1.y+v2.y}),
    sub: (v1,v2) => ({x:v1.x-v2.x, y:v1.y-v2.y}),
    mult: (v,n) => ({x:v.x*n, y:v.y*n}),
    mag: (v) => Math.sqrt(v.x*v.x + v.y*v.y),
    norm: (v) => { let m=Vector.mag(v); return m===0?{x:0,y:0}:{x:v.x/m, y:v.y/m}; },
    dist: (v1,v2) => Math.sqrt((v1.x-v2.x)**2 + (v1.y-v2.y)**2)
};
const Rand = (min,max) => Math.random()*(max-min)+min;

/** ---------------- GAME CONSTANTS ---------------- */
const CONFIG = {
    w: 1800, h: 1800,
    gemRate: 180, // 3sec @ 60fps
    gemRadius: 24,
    gemPickRadius: 100, // Magnet Start
    gemCollectDist: 20, // Actual Collect
    regenWait: 180, // 3sec no dmg
};

/** ---------------- CLASSES ---------------- */
class Brawler {
    constructor(x, y, team, type, isBot, name) {
        this.pos = {x, y};
        this.team = team; this.type = type; this.isBot = isBot; this.name = name;
        this.vel = {x:0, y:0};
        this.radius = 40;
        this.dead = false; this.respawnTime = 0;
        this.lastActionTime = 0; // For regen
        this.stats = {kills:0, deaths:0, gems:0};
        this.gemsHeld = 0;
        
        // Settings
        if (type==='tank') { this.hp=6800; this.maxHp=6800; this.speed=5.0; this.range=180; this.dmg=1200; this.reload=45; this.isMelee=true; }
        else if (type==='sniper') { this.hp=3200; this.maxHp=3200; this.speed=6.0; this.range=900; this.dmg=950; this.reload=40; this.isMelee=false; }
        else { this.hp=4400; this.maxHp=4400; this.speed=5.5; this.range=480; this.dmg=440; this.reload=50; this.isMelee=false; }
        
        this.cooldown = 0;
    }

    update() {
        if(this.dead) {
            this.respawnTime--;
            if(this===player) document.getElementById('respawn-timer').innerText = Math.ceil(this.respawnTime/60);
            if(this.respawnTime<=0) this.respawn();
            return;
        }

        // Regen Logic
        if(Date.now() - this.lastActionTime > 3000 && this.hp < this.maxHp) {
            this.hp += this.maxHp * 0.005; // 0.5% per tick
            if(this.hp > this.maxHp) this.hp = this.maxHp;
        }

        // Physics
        this.vel = Vector.mult(this.vel, 0.85);
        this.pos = Vector.add(this.pos, this.vel);
        if(this.cooldown>0) this.cooldown--;

        // Wall collision
        this.pos.x = Math.max(this.radius, Math.min(CONFIG.w-this.radius, this.pos.x));
        this.pos.y = Math.max(this.radius, Math.min(CONFIG.h-this.radius, this.pos.y));

        if(this.isBot) this.updateAI();
    }

    shoot(aim) {
        if(this.dead || this.cooldown>0) return;
        this.cooldown = this.reload;
        this.lastActionTime = Date.now();
        Audio.shoot(this.type);

        if(this.isMelee) {
            effects.push(new Effect(this.pos.x+aim.x*50, this.pos.y+aim.y*50, 'punch'));
            brawlers.forEach(b => {
                if(b.team!==this.team && !b.dead && Vector.dist(this.pos, b.pos) < this.range) {
                    b.hit(this.dmg, this);
                }
            });
        } else {
            const cnt = this.type==='fighter'?3:1;
            const spr = this.type==='fighter'?0.35:0;
            const spd = 24;
            let ang = Math.atan2(aim.y, aim.x) - spr/2;
            for(let i=0; i<cnt; i++) {
                let a = ang + (cnt>1?(spr/(cnt-1))*i:0);
                bullets.push(new Bullet(this.pos.x, this.pos.y, {x:Math.cos(a)*spd, y:Math.sin(a)*spd}, this.dmg, this.team, this.range, this));
            }
        }
    }

    hit(dmg, attacker) {
        if(this.dead) return;
        this.hp -= dmg;
        this.lastActionTime = Date.now();
        Audio.hit();
        effects.push(new TextEffect(Math.floor(dmg), this.pos.x, this.pos.y-40, '#fff'));
        
        if(this.hp <= 0) {
            this.dead = true;
            this.respawnTime = 180;
            this.stats.deaths++;
            if(attacker) attacker.stats.kills++;
            Audio.die();
            effects.push(new TextEffect("DOWN!", this.pos.x, this.pos.y, 'red'));
            
            // Scatter Gems
            let drop = Math.floor(this.gemsHeld); // Drop all
            this.gemsHeld = 0;
            for(let i=0; i<drop; i++) {
                // Scatter Physics
                let angle = Math.random() * Math.PI * 2;
                let speed = Rand(5, 15);
                gems.push(new Gem(this.pos.x, this.pos.y, {x:Math.cos(angle)*speed, y:Math.sin(angle)*speed}));
            }

            if(this===player) document.getElementById('respawn-overlay').classList.remove('hidden');
        }
    }

    respawn() {
        this.dead = false; this.hp = this.maxHp; this.gemsHeld = 0; this.cooldown = 0;
        this.pos = this.team==='blue' ? {x:200, y:CONFIG.h/2+Rand(-200,200)} : {x:CONFIG.w-200, y:CONFIG.h/2+Rand(-200,200)};
        effects.push(new TextEffect("GO!", this.pos.x, this.pos.y, '#00E676'));
        if(this===player) document.getElementById('respawn-overlay').classList.add('hidden');
    }

    updateAI() {
        // --- SMARTER AI ---
        let enemies = brawlers.filter(b => b.team !== this.team && !b.dead);
        let nearestEnemy = null, minEDist = 9999;
        enemies.forEach(e => { let d=Vector.dist(this.pos, e.pos); if(d<minEDist){minEDist=d; nearestEnemy=e;} });

        let nearestGem = null, minGDist = 9999;
        gems.filter(g=>!g.target).forEach(g => { let d=Vector.dist(this.pos, g.pos); if(d<minGDist){minGDist=d; nearestGem=g;} });

        let moveDir = {x:0, y:0};
        let shootTarget = null;
        let hpPct = this.hp / this.maxHp;

        // 1. SURVIVAL (Low HP or Many Gems)
        if (hpPct < 0.3 || this.gemsHeld >= 8) {
            if (nearestEnemy && minEDist < 600) {
                // Run away from enemy
                moveDir = Vector.norm(Vector.sub(this.pos, nearestEnemy.pos));
            } else if (hpPct < 0.3) {
                // Stay still/retreat to heal
                let home = this.team==='blue' ? {x:100, y:CONFIG.h/2} : {x:CONFIG.w-100, y:CONFIG.h/2};
                moveDir = Vector.norm(Vector.sub(home, this.pos));
            }
        } 
        // 2. COLLECT (Safe)
        else if (nearestGem && minGDist < 500) {
            moveDir = Vector.norm(Vector.sub(nearestGem.pos, this.pos));
        }
        // 3. COMBAT
        else if (nearestEnemy) {
            let dist = Vector.dist(this.pos, nearestEnemy.pos);
            let optimalDist = this.type==='sniper' ? 700 : (this.type==='tank' ? 0 : 300);
            
            if (dist > optimalDist + 50) {
                moveDir = Vector.norm(Vector.sub(nearestEnemy.pos, this.pos)); // Chase
            } else if (dist < optimalDist - 50) {
                moveDir = Vector.norm(Vector.sub(this.pos, nearestEnemy.pos)); // Back up
            } else {
                // Strafe
                let dir = Vector.norm(Vector.sub(nearestEnemy.pos, this.pos));
                moveDir = {x: -dir.y, y: dir.x}; // Perpendicular
                if(Math.random()<0.02) moveDir = Vector.mult(moveDir, -1);
            }
            shootTarget = nearestEnemy;
        } 
        // 4. IDLE (Center)
        else {
            moveDir = Vector.norm(Vector.sub({x:CONFIG.w/2, y:CONFIG.h/2}, this.pos));
        }

        // Apply Move
        this.vel = Vector.add(this.vel, Vector.mult(moveDir, 0.5)); // Accel
        if (Vector.mag(this.vel) > this.speed) this.vel = Vector.mult(Vector.norm(this.vel), this.speed);

        // Apply Shoot
        if (shootTarget && minEDist < this.range && Math.random() < 0.08) {
            let predPos = Vector.add(shootTarget.pos, Vector.mult(shootTarget.vel, 5)); // Simple prediction
            this.shoot(Vector.norm(Vector.sub(predPos, this.pos)));
        }
    }
}

class Bullet {
    constructor(x,y,vel,dmg,team,range,owner) {
        this.pos={x,y}; this.vel=vel; this.dmg=dmg; this.team=team; this.range=range; this.owner=owner;
        this.dist=0; this.dead=false;
    }
    update() {
        this.pos = Vector.add(this.pos, this.vel);
        this.dist += Vector.mag(this.vel);
        if(this.dist >= this.range) this.dead=true;
        
        brawlers.forEach(b => {
            if(b.team!==this.team && !b.dead && Vector.dist(this.pos, b.pos) < b.radius+10) {
                b.hit(this.dmg, this.owner);
                this.dead=true;
                effects.push(new Effect(this.pos.x, this.pos.y, 'hit', this.team));
            }
        });
    }
}

class Gem {
    constructor(x, y, initVel={x:0, y:0}) {
        this.pos = {x, y};
        this.vel = initVel; // For scattering
        this.target = null; // For magnet
        this.dead = false;
        this.floatY = 0;
    }
    update() {
        // Scattering Physics
        if (Vector.mag(this.vel) > 0.1) {
            this.pos = Vector.add(this.pos, this.vel);
            this.vel = Vector.mult(this.vel, 0.9); // Friction
            // Wall bounce
            if(this.pos.x<0 || this.pos.x>CONFIG.w) this.vel.x*=-1;
            if(this.pos.y<0 || this.pos.y>CONFIG.h) this.vel.y*=-1;
        }

        // Magnet Logic
        if (!this.target) {
            this.floatY = Math.sin(Date.now()/300)*5;
            // Find target
            brawlers.forEach(b => {
                if(!b.dead && Vector.dist(this.pos, b.pos) < CONFIG.gemPickRadius) {
                    this.target = b;
                }
            });
        } else {
            if (this.target.dead) { this.target = null; return; }
            
            // Suck in
            let dir = Vector.norm(Vector.sub(this.target.pos, this.pos));
            let speed = 25; // Fast suck
            this.pos = Vector.add(this.pos, Vector.mult(dir, speed));

            if (Vector.dist(this.pos, this.target.pos) < CONFIG.gemCollectDist) {
                this.dead = true;
                this.target.gemsHeld++;
                this.target.stats.gems++;
                Audio.gem();
                effects.push(new TextEffect("+1", this.target.pos.x, this.target.pos.y-60, '#D500F9'));
            }
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y + (this.target?0:this.floatY));
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 20, 10, 5, 0, 0, Math.PI*2); ctx.fill();
        
        // Gem Body
        ctx.fillStyle = '#D500F9';
        ctx.beginPath();
        ctx.moveTo(0, -20); ctx.lineTo(18, -5); ctx.lineTo(0, 15); ctx.lineTo(-18, -5);
        ctx.fill();
        // Shine
        ctx.fillStyle = '#F3E5F5';
        ctx.beginPath();
        ctx.moveTo(0, -20); ctx.lineTo(12, -5); ctx.lineTo(0, 0); ctx.lineTo(-12, -5);
        ctx.fill();
        
        ctx.restore();
    }
}

class Effect {
    constructor(x,y,type,color) {
        this.pos={x,y}; this.type=type; this.life=15; this.maxLife=15; this.color=color;
    }
    update() { this.life--; }
    draw(ctx) {
        let alpha = this.life/this.maxLife;
        if(this.type==='hit') {
            ctx.fillStyle = this.color==='blue'?'#80D8FF':'#FF8A80';
            ctx.globalAlpha = alpha;
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 20*(1-alpha), 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha=1;
        } else if(this.type==='punch') {
            ctx.strokeStyle = '#fff'; ctx.lineWidth=5; ctx.globalAlpha=alpha;
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 30+20*(1-alpha), 0, Math.PI*2); ctx.stroke();
            ctx.globalAlpha=1;
        }
    }
}

class TextEffect {
    constructor(text,x,y,color) {
        this.text=text; this.pos={x,y}; this.color=color; this.life=50;
    }
    update() { this.pos.y-=1; this.life--; }
    draw(ctx) {
        if(this.life<=0) return;
        ctx.font = "900 30px 'Fredoka'";
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'black'; ctx.lineWidth=4;
        ctx.strokeText(this.text, this.pos.x, this.pos.y);
        ctx.fillText(this.text, this.pos.x, this.pos.y);
    }
}

/** ---------------- MAIN LOOP ---------------- */
const cvs = document.getElementById('gameCanvas');
const ctx = cvs.getContext('2d');
let gameActive = false;
let brawlers=[], bullets=[], gems=[], effects=[];
let player;
let gemTimer=0, gameTime=0;
let cdTime=10, cdActive=false, winTeam=null;
let camera={x:0,y:0};
let inputs={move:{x:0,y:0}, aim:{x:0,y:0}};
let playerType='fighter';
let floorPattern;

function init() {
    setupJoystick('stick-left', 'move');
    setupJoystick('stick-right', 'aim');
    resize();
    // Pattern
    let p = document.createElement('canvas'); p.width=100; p.height=100;
    let pc = p.getContext('2d');
    pc.fillStyle='#212121'; pc.fillRect(0,0,100,100);
    pc.fillStyle='#2b2b2b'; pc.fillRect(0,0,50,50); pc.fillRect(50,50,50,50);
    floorPattern = ctx.createPattern(p,'repeat');
    loop();
}

function startGame() {
    Audio.resume();
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    
    brawlers=[]; bullets=[]; gems=[]; effects=[];
    gameActive=true; cdActive=false; cdTime=10; winTeam=null;
    
    // Create Teams
    player = new Brawler(200, CONFIG.h/2, 'blue', playerType, false, "YOU");
    brawlers.push(player);
    brawlers.push(new Brawler(200, CONFIG.h/2-300, 'blue', 'sniper', true, "ALLY 1"));
    brawlers.push(new Brawler(200, CONFIG.h/2+300, 'blue', 'tank', true, "ALLY 2"));
    brawlers.push(new Brawler(CONFIG.w-200, CONFIG.h/2, 'red', 'fighter', true, "ENEMY 1"));
    brawlers.push(new Brawler(CONFIG.w-200, CONFIG.h/2-300, 'red', 'sniper', true, "ENEMY 2"));
    brawlers.push(new Brawler(CONFIG.w-200, CONFIG.h/2+300, 'red', 'tank', true, "ENEMY 3"));
}

function loop() {
    requestAnimationFrame(loop);
    
    // Clear
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,cvs.width,cvs.height);
    
    if(!gameActive) return;
    
    // --- UPDATE ---
    
    // Gem Spawning
    gemTimer++;
    if(gemTimer > CONFIG.gemRate && gems.length < 20) {
        gems.push(new Gem(CONFIG.w/2 + Rand(-150,150), CONFIG.h/2 + Rand(-150,150)));
        gemTimer=0;
    }

    // Player Input
    if(Vector.mag(inputs.move) > 0.1 && !player.dead) {
        let spd = player.speed;
        player.vel = Vector.add(player.vel, Vector.mult(inputs.move, 0.8));
        if(Vector.mag(player.vel) > spd) player.vel = Vector.mult(Vector.norm(player.vel), spd);
    }
    
    // Entities
    [...brawlers, ...bullets, ...gems, ...effects].forEach(e => e.update());
    
    // Cleanup
    bullets = bullets.filter(b=>!b.dead);
    gems = gems.filter(g=>!g.dead);
    effects = effects.filter(e=>e.life>0);

    // Camera
    camera.x += (player.pos.x - camera.x) * 0.1;
    camera.y += (player.pos.y - camera.y) * 0.1;

    // Game Logic (Score)
    let bScore = brawlers.filter(b=>b.team==='blue').reduce((a,c)=>a+c.gemsHeld,0);
    let rScore = brawlers.filter(b=>b.team==='red').reduce((a,c)=>a+c.gemsHeld,0);
    document.getElementById('score-blue-val').innerText = bScore;
    document.getElementById('score-red-val').innerText = rScore;
    
    let leadTeam = null;
    if(bScore>=10 && bScore>rScore) leadTeam='blue';
    else if(rScore>=10 && rScore>bScore) leadTeam='red';
    
    let cdEl = document.getElementById('countdown-container');
    let cdNum = document.getElementById('countdown-number');
    
    if(leadTeam) {
        if(winTeam !== leadTeam) { winTeam = leadTeam; cdTime = 10; cdActive = true; cdEl.style.display='block'; }
        
        let oldInt = Math.ceil(cdTime);
        cdTime -= 1/60;
        if(Math.ceil(cdTime) !== oldInt) {
            Audio.count();
            cdNum.innerText = Math.ceil(cdTime);
            cdNum.className = leadTeam==='blue' ? 'cd-number cd-blue' : 'cd-number cd-red';
        }
        
        if(cdTime <= 0) endGame(leadTeam);
    } else {
        winTeam=null; cdActive=false; cdEl.style.display='none';
    }

    // --- DRAW ---
    ctx.save();
    ctx.translate(cvs.width/2, cvs.height/2);
    ctx.scale(0.7, 0.7); // Zoom out
    ctx.translate(-camera.x, -camera.y);

    // Floor
    ctx.fillStyle = floorPattern;
    ctx.fillRect(0,0,CONFIG.w, CONFIG.h);
    
    // Walls
    ctx.strokeStyle = '#555'; ctx.lineWidth=20; ctx.strokeRect(0,0,CONFIG.w, CONFIG.h);
    
    // Mine
    ctx.beginPath(); ctx.arc(CONFIG.w/2, CONFIG.h/2, 120, 0, Math.PI*2);
    ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fill();
    ctx.strokeStyle='#E040FB'; ctx.lineWidth=5; ctx.setLineDash([15,15]); ctx.stroke(); ctx.setLineDash([]);

    // Objects
    gems.forEach(g => g.draw(ctx));
    
    brawlers.forEach(b => {
        if(b.dead) return;
        // Shadow
        ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(b.pos.x, b.pos.y+15, 30, 15, 0, 0, Math.PI*2); ctx.fill();
        
        // Body (Circle)
        ctx.fillStyle = b.team==='blue' ? '#2196F3' : '#E91E63';
        ctx.beginPath(); ctx.arc(b.pos.x, b.pos.y, b.radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth=4; ctx.stroke();
        
        // Aim Guide (Player)
        if(b===player && Vector.mag(inputs.aim)>0.1) {
            ctx.save(); ctx.translate(b.pos.x, b.pos.y); ctx.rotate(Math.atan2(inputs.aim.y, inputs.aim.x));
            ctx.fillStyle='rgba(255,255,255,0.3)';
            ctx.beginPath();
            if(b.type==='fighter') { ctx.moveTo(0,0); ctx.lineTo(b.range, -60); ctx.lineTo(b.range, 60); }
            else { ctx.fillRect(0, -15, b.range, 30); }
            ctx.fill(); ctx.restore();
        }

        // Info
        ctx.textAlign='center';
        // HP Bar
        let hpPct = b.hp/b.maxHp;
        ctx.fillStyle='#333'; ctx.fillRect(b.pos.x-35, b.pos.y-75, 70, 10);
        ctx.fillStyle=hpPct>0.3?'#76FF03':'#FF1744'; ctx.fillRect(b.pos.x-35, b.pos.y-75, 70*hpPct, 10);
        ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.strokeRect(b.pos.x-35, b.pos.y-75, 70, 10);
        
        // Reload Bar
        if(b.reload>0) {
            let rPct = 1 - (b.cooldown/b.reload);
            ctx.fillStyle='#333'; ctx.fillRect(b.pos.x-35, b.pos.y-63, 70, 5);
            ctx.fillStyle=rPct>=1?'#FF9100':'#aaa'; ctx.fillRect(b.pos.x-35, b.pos.y-63, 70*rPct, 5);
        }

        // Name
        ctx.font="800 18px 'M PLUS Rounded 1c'"; ctx.fillStyle='#fff'; ctx.strokeStyle='#000'; ctx.lineWidth=3;
        ctx.strokeText(b.name, b.pos.x, b.pos.y-85); ctx.fillText(b.name, b.pos.x, b.pos.y-85);
        
        // Gems
        if(b.gemsHeld>0) {
            ctx.font="800 24px 'Fredoka'";
            ctx.strokeText("üíé"+b.gemsHeld, b.pos.x, b.pos.y-110);
            ctx.fillText("üíé"+b.gemsHeld, b.pos.x, b.pos.y-110);
        }
    });

    bullets.forEach(b => {
        ctx.fillStyle = b.team==='blue'?'#80D8FF':'#FF8A80';
        ctx.beginPath(); ctx.arc(b.pos.x, b.pos.y, 12, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
    });

    effects.forEach(e => e.draw(ctx));

    ctx.restore();
}

function endGame(winner) {
    gameActive = false;
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('result-screen').classList.remove('hidden');
    
    let title = document.getElementById('result-title');
    title.innerText = winner==='blue' ? "VICTORY!" : "DEFEAT";
    title.className = winner==='blue' ? "result-header win" : "result-header lose";
    
    // MVP Logic
    let mvp = brawlers.sort((a,b) => (b.stats.kills*2 + b.stats.gems) - (a.stats.kills*2 + a.stats.gems))[0];
    document.getElementById('mvp-text').innerText = "MVP: " + mvp.name;
    
    let tb = document.getElementById('stats-body'); tb.innerHTML = '';
    brawlers.forEach(b => {
        let tr = document.createElement('tr');
        if(b===mvp) tr.className = 'mvp';
        let nameHtml = b.name + (b===player ? "<span class='me-badge'>YOU</span>" : "");
        tr.innerHTML = `<td style="text-align:left; padding-left:20px;">${nameHtml}</td><td>${b.stats.kills}</td><td>${b.stats.deaths}</td><td>${b.stats.gems}</td>`;
        tb.appendChild(tr);
    });
}

function resetGame() {
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('main-menu').classList.remove('hidden');
}

function selectChar(type, el) {
    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected'); playerType = type;
}

function setupJoystick(id, type) {
    const zone = document.getElementById(id);
    const handle = zone.querySelector('.joystick-handle');
    let tid = null, origin = {x:0,y:0};
    const move = (cx,cy) => {
        let dx=cx-origin.x, dy=cy-origin.y, dist=Math.sqrt(dx*dx+dy*dy), max=60, ang=Math.atan2(dy,dx);
        if(dist>max){dx=Math.cos(ang)*max; dy=Math.sin(ang)*max;}
        handle.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        let v={x:dx/max, y:dy/max};
        if(type==='move') inputs.move=v; else inputs.aim=v;
    };
    const start = (e) => {
        e.preventDefault(); let t=e.changedTouches?e.changedTouches[0]:e;
        if(e.changedTouches) tid=t.identifier;
        let r=zone.getBoundingClientRect(); origin={x:r.left+r.width/2, y:r.top+r.height/2};
        move(t.clientX, t.clientY);
    };
    const end = (e) => {
        e.preventDefault(); tid=null; handle.style.transform='translate(-50%,-50%)';
        if(type==='move') inputs.move={x:0,y:0};
        else { if(Vector.mag(inputs.aim)>0.2) player.shoot(inputs.aim); inputs.aim={x:0,y:0}; }
    };
    zone.addEventListener('touchstart', start, {passive:false});
    zone.addEventListener('touchmove', e=>{e.preventDefault(); let t=[...e.changedTouches].find(x=>x.identifier===tid); if(t) move(t.clientX, t.clientY);}, {passive:false});
    zone.addEventListener('touchend', end, {passive:false});
    zone.addEventListener('mousedown', start);
    window.addEventListener('mousemove', e=>{if(tid!==null && !e.changedTouches) move(e.clientX, e.clientY);});
    window.addEventListener('mouseup', e=>{if(tid!==null && !e.changedTouches) end(e);});
}

function resize() { cvs.width = window.innerWidth; cvs.height = window.innerHeight; }
window.addEventListener('resize', resize);
window.onload = init;
</script>
</body>
</html>
