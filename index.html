<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Royale - Refined</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700&family=M+PLUS+Rounded+1c:wght@500;800&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #FFC107;
            --blue-team: #007BFF;
            --red-team: #FF3B30;
            /* Â§âÊõ¥: Ë™≠„Åø„ÇÑ„Åô„Åè„É¢„ÉÄ„É≥„Å™„Éï„Ç©„É≥„ÉàË®≠ÂÆö */
            --header-font: 'Fredoka', sans-serif;
            --body-font: 'M PLUS Rounded 1c', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            background-color: #121212;
            overflow: hidden;
            font-family: var(--body-font);
            color: white;
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-family: var(--header-font);
            font-size: 4rem;
            color: var(--primary);
            text-shadow: 0 5px 0 #E65100;
            margin-bottom: 10px;
            text-align: center;
            line-height: 1;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #ccc;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        /* „Ç≠„É£„É©ÈÅ∏Êäû */
        .card-container {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .char-card {
            background: #2c2c2c;
            border: 3px solid #555;
            border-radius: 20px;
            padding: 20px;
            width: 150px;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
        }

        .char-card:hover, .char-card.selected {
            transform: translateY(-8px);
            border-color: var(--primary);
            background: #3e3e3e;
            box-shadow: 0 10px 20px rgba(255, 193, 7, 0.2);
        }

        .char-icon { font-size: 3rem; margin-bottom: 10px; }
        .char-name { font-weight: 800; font-size: 1.1rem; }

        .btn-start {
            font-family: var(--header-font);
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(to bottom, #FFCA28, #FF6F00);
            color: #fff;
            border: none;
            padding: 15px 60px;
            border-radius: 60px;
            border-bottom: 6px solid #E65100;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            text-shadow: 0 2px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .btn-start:active { transform: translateY(4px); border-bottom-width: 2px; }

        /* --- HUD --- */
        .score-board {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-family: var(--header-font);
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.6);
            padding: 5px 30px;
            border-radius: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            z-index: 20;
            align-items: center;
        }
        .score-blue { color: #40C4FF; display:flex; align-items:center; gap:10px; }
        .score-red { color: #FF5252; display:flex; align-items:center; gap:10px; }
        .gem-icon { font-size: 1.8rem; filter: drop-shadow(0 0 5px rgba(213,0,249,0.8)); }

        /* „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥Ë°®Á§∫ */
        #countdown-overlay {
            position: absolute;
            top: 15%; left: 0; width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 40;
            display: none;
        }
        .countdown-text {
            font-family: var(--header-font);
            font-size: 5rem;
            font-weight: 700;
            -webkit-text-stroke: 2px black;
            animation: pulse 1s infinite;
        }
        .cd-blue { color: #40C4FF; text-shadow: 0 0 20px #007BFF; }
        .cd-red { color: #FF5252; text-shadow: 0 0 20px #FF3B30; }

        /* Âæ©Ê¥ª„Çø„Ç§„Éû„Éº */
        #respawn-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 50;
        }
        .respawn-label { font-size: 1.5rem; color:white; margin-bottom: 10px; }
        .respawn-count {
            font-family: var(--header-font);
            font-size: 6rem;
            color: #ffca28;
            text-shadow: 4px 4px 0 #000;
        }

        /* „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ */
        .joystick-zone { position: absolute; bottom: 40px; width: 160px; height: 160px; pointer-events: auto; z-index: 30; }
        #stick-left { left: 40px; }
        #stick-right { right: 40px; }
        .joystick-base {
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            position: relative;
            border: 3px solid rgba(255, 255, 255, 0.2);
        }
        .joystick-handle {
            width: 60px; height: 60px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #stick-right .joystick-handle { background: #ff5252; }

        /* „É™„Ç∂„É´„Éà */
        .stats-table {
            width: 90%; max-width: 600px;
            background: #222; border-radius: 15px;
            border-collapse: collapse; overflow: hidden;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .stats-table th { background: #333; color: #888; padding: 15px; font-weight: normal; }
        .stats-table td { padding: 15px; text-align: center; border-bottom: 1px solid #333; font-weight: bold; font-size: 1.2rem; }
        .row-blue { color: #40C4FF; }
        .row-red { color: #FF5252; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="hud" class="hidden">
            <div class="score-board">
                <div class="score-blue"><span id="score-blue-val">0</span> <span class="gem-icon">üíé</span></div>
                <div style="margin:0 15px; opacity:0.5;">:</div>
                <div class="score-red"><span class="gem-icon">üíé</span> <span id="score-red-val">0</span></div>
            </div>

            <div id="countdown-overlay">
                <div id="countdown-text" class="countdown-text">10</div>
            </div>
            
            <div id="respawn-overlay" class="hidden">
                <div class="respawn-label">Âæ©Ê¥ª„Åæ„Åß</div>
                <div class="respawn-count" id="respawn-timer">3</div>
            </div>

            <div id="stick-left" class="joystick-zone">
                <div class="joystick-base"><div class="joystick-handle"></div></div>
            </div>
            <div id="stick-right" class="joystick-zone">
                <div class="joystick-base"><div class="joystick-handle"></div></div>
            </div>
        </div>

        <div id="main-menu" class="overlay">
            <h1>GEM ROYALE</h1>
            <div class="subtitle">„Ç∏„Çß„É†„Éª„É≠„ÉØ„Ç§„É§„É´</div>
            
            <div class="card-container">
                <div class="char-card selected" onclick="selectChar('fighter', this)">
                    <div class="char-icon">ü§†</div>
                    <div class="char-name">„Éï„Ç°„Ç§„Çø„Éº</div>
                </div>
                <div class="char-card" onclick="selectChar('sniper', this)">
                    <div class="char-icon">üëÆ</div>
                    <div class="char-name">„Çπ„Éä„Ç§„Éë„Éº</div>
                </div>
                <div class="char-card" onclick="selectChar('tank', this)">
                    <div class="char-icon">ü§º</div>
                    <div class="char-name">„Çø„É≥„ÇØ</div>
                </div>
            </div>

            <button class="btn-start" onclick="startGame()">BATTLE START</button>
        </div>

        <div id="result-screen" class="overlay hidden">
            <h2 id="result-title" style="font-family: var(--header-font); font-size: 5rem; margin: 0; text-shadow: 0 5px 0 rgba(0,0,0,0.5);">VICTORY</h2>
            
            <table class="stats-table">
                <thead>
                    <tr><th>NAME</th><th>KILLS</th><th>DEATHS</th><th>GEMS</th></tr>
                </thead>
                <tbody id="stats-body"></tbody>
            </table>

            <button class="btn-start" onclick="resetGame()">PLAY AGAIN</button>
        </div>
    </div>

<script>
/**
 * AUDIO MANAGER
 */
class AudioManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.isPlaying = false;
    }
    resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
    
    playTone(freq, type, duration, vol=0.1, slide=null) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide) osc.frequency.linearRampToValueAtTime(slide, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playShoot(type) {
        if (type === 'sniper') this.playTone(800, 'square', 0.15, 0.05, 400);
        else if (type === 'tank') this.playTone(100, 'sawtooth', 0.2, 0.1, 50);
        else this.playTone(400, 'triangle', 0.1, 0.05, 200);
    }
    playHit() { this.playTone(150, 'sawtooth', 0.1, 0.05); }
    playGem() { this.playTone(1500, 'sine', 0.3, 0.1, 2000); }
    playDie() { this.playTone(400, 'triangle', 0.6, 0.2, 50); }
    playCount() { this.playTone(800, 'sine', 0.1, 0.1); }
    
    startBGM() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.beatInterval = setInterval(() => {
            if(!gameActive) return;
            this.playTone(60, 'sine', 0.1, 0.2); // Kick
            setTimeout(() => this.playTone(800, 'square', 0.05, 0.01), 250); // Hat
            setTimeout(() => this.playTone(200, 'sawtooth', 0.1, 0.05), 500); // Snare
            setTimeout(() => this.playTone(800, 'square', 0.05, 0.01), 750); // Hat
        }, 1000);
    }
}
const Audio = new AudioManager();

/**
 * UTILS
 */
function createPattern(color1, color2, size=64) {
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const ctx = c.getContext('2d');
    ctx.fillStyle = color1; ctx.fillRect(0,0,size,size);
    ctx.fillStyle = color2; ctx.globalAlpha = 0.05;
    ctx.beginPath(); ctx.arc(size/2, size/2, size/4, 0, Math.PI*2); ctx.fill();
    return CTX.createPattern(c, 'repeat');
}

/**
 * GAME ENGINE
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');

const CONFIG = {
    mapWidth: 1600,
    mapHeight: 1600,
    tileSize: 100,
    gemSpawnRate: 180, // 3Áßí (60fps * 3)
    cameraScale: 0.7,
    winGemCount: 10,
    winTime: 10 // 10Áßí„Ç≠„Éº„Éó
};

let gameActive = false;
let camera = { x: 0, y: 0 };
let playerType = 'fighter';
let floorPattern;

// Game State Variables
let countdownActive = false;
let countdownTimer = 10;
let winningTeam = null;

class Vector {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m);
    }
}

class Entity {
    constructor(x, y, radius) {
        this.pos = new Vector(x, y);
        this.radius = radius;
        this.dead = false;
    }
}

class Brawler extends Entity {
    constructor(x, y, team, type, isBot = false, name) {
        super(x, y, 40);
        this.team = team;
        this.type = type;
        this.isBot = isBot;
        this.name = name;
        this.velocity = new Vector(0, 0);
        this.respawnTimer = 0;
        this.stats = { kills: 0, deaths: 0, gems: 0 };

        if (type === 'tank') {
            this.maxHp = 6500; this.speed = 5; this.range = 180;
            this.damage = 1100; this.reloadTime = 50;
            this.color = team==='blue' ? '#2979FF' : '#FF1744';
            this.isMelee = true;
        } else if (type === 'sniper') {
            this.maxHp = 3000; this.speed = 6; this.range = 950;
            this.damage = 900; this.reloadTime = 40;
            this.color = team==='blue' ? '#40C4FF' : '#FF5252';
            this.isMelee = false;
        } else {
            this.maxHp = 4400; this.speed = 5.5; this.range = 450;
            this.damage = 420; this.reloadTime = 45;
            this.color = team==='blue' ? '#00B0FF' : '#D50000';
            this.isMelee = false;
        }
        
        this.hp = this.maxHp;
        this.gemsHeld = 0;
        this.cooldown = 0;
    }

    update() {
        if (this.dead) {
            this.respawnTimer--;
            if (this === player) {
                document.getElementById('respawn-timer').innerText = Math.ceil(this.respawnTimer / 60);
            }
            if (this.respawnTimer <= 0) this.respawn();
            return;
        }

        this.velocity = this.velocity.mult(0.85);
        this.pos = this.pos.add(this.velocity);
        if (this.cooldown > 0) this.cooldown--;

        this.pos.x = Math.max(this.radius, Math.min(CONFIG.mapWidth - this.radius, this.pos.x));
        this.pos.y = Math.max(this.radius, Math.min(CONFIG.mapHeight - this.radius, this.pos.y));

        if (this.isBot) this.updateAI();
    }

    shoot(aimVector) {
        if (this.dead || this.cooldown > 0) return;
        this.cooldown = this.reloadTime;
        Audio.playShoot(this.type);

        if (this.isMelee) {
            particles.push(new Particle(this.pos.x + aimVector.x*50, this.pos.y + aimVector.y*50, 80, '#fff', 10));
            brawlers.forEach(b => {
                if (b.team !== this.team && !b.dead) {
                    if (b.pos.sub(this.pos).mag() < this.range) {
                        b.takeDamage(this.damage, this);
                    }
                }
            });
        } else {
            const count = this.type === 'fighter' ? 3 : 1;
            const spread = this.type === 'fighter' ? 0.35 : 0;
            const speed = 24;
            let baseAngle = Math.atan2(aimVector.y, aimVector.x);
            let startAngle = baseAngle - spread/2;
            
            for(let i=0; i<count; i++) {
                let angle = startAngle + (count > 1 ? (spread/(count-1))*i : 0);
                let vel = new Vector(Math.cos(angle)*speed, Math.sin(angle)*speed);
                projectiles.push(new Projectile(this.pos.x, this.pos.y, vel, this.damage, this.team, this.range, this));
            }
        }
    }

    takeDamage(amount, attacker) {
        if (this.dead) return;
        this.hp -= amount;
        spawnFloatingText(Math.floor(amount), this.pos.x, this.pos.y - 40, '#fff');
        Audio.playHit();
        if (this.hp <= 0) this.die(attacker);
    }

    die(attacker) {
        this.dead = true;
        this.respawnTimer = 180; // 3 seconds
        this.stats.deaths++;
        if (attacker) attacker.stats.kills++;
        Audio.playDie();
        
        let drop = Math.floor(this.gemsHeld / 2) + 1; // Always drop at least 1 if holding? No, drop half + base logic
        if (this.gemsHeld === 0) drop = 0;
        else drop = Math.max(1, Math.floor(this.gemsHeld/2));

        this.gemsHeld = 0;
        for(let i=0; i<drop; i++) {
            gems.push(new Gem(this.pos.x + (Math.random()*60-30), this.pos.y + (Math.random()*60-30)));
        }
        
        spawnFloatingText("DOWN!", this.pos.x, this.pos.y, 'red');
        if (this === player) document.getElementById('respawn-overlay').classList.remove('hidden');
    }

    respawn() {
        this.dead = false;
        this.hp = this.maxHp;
        this.cooldown = 0;
        this.pos = this.team === 'blue' 
            ? new Vector(150, CONFIG.mapHeight/2 + Math.random()*200-100)
            : new Vector(CONFIG.mapWidth-150, CONFIG.mapHeight/2 + Math.random()*200-100);
        
        spawnFloatingText("GO!", this.pos.x, this.pos.y, '#00E676');
        if (this === player) document.getElementById('respawn-overlay').classList.add('hidden');
    }

    updateAI() {
        // AI Logic
        let target = null;
        let mode = 'hunt';
        
        // Find Gems
        let nearestGem = null, minGemDist = 9999;
        gems.forEach(g => {
            let d = this.pos.sub(g.pos).mag();
            if (d < minGemDist) { minGemDist = d; nearestGem = g; }
        });

        // Find Enemy
        let nearestEnemy = null, minEnemyDist = 9999;
        brawlers.forEach(b => {
            if (b.team !== this.team && !b.dead) {
                let d = this.pos.sub(b.pos).mag();
                if (d < minEnemyDist) { minEnemyDist = d; nearestEnemy = b; }
            }
        });

        // Decision
        if (nearestGem && this.gemsHeld < 10 && minGemDist < 500) {
            target = nearestGem.pos; mode = 'collect';
        } else if (nearestEnemy) {
            target = nearestEnemy.pos;
            // If winning or holding many gems, play safe
            if (this.gemsHeld >= 8 || (winningTeam === this.team && countdownActive)) {
                 mode = 'flee';
            }
        } else {
            target = new Vector(CONFIG.mapWidth/2, CONFIG.mapHeight/2);
        }

        if (target) {
            let dir = target.sub(this.pos).normalize();
            if (mode === 'flee') dir = dir.mult(-1);
            
            this.velocity = this.velocity.add(dir.mult(0.6));
            if (this.velocity.mag() > this.speed) this.velocity = this.velocity.normalize().mult(this.speed);

            if (mode !== 'collect' && mode !== 'flee' && nearestEnemy && minEnemyDist < this.range && Math.random() < 0.05) {
                 this.shoot(nearestEnemy.pos.sub(this.pos));
            }
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, vel, damage, team, range, owner) {
        super(x, y, 14);
        this.velocity = vel;
        this.damage = damage;
        this.team = team;
        this.maxDist = range;
        this.dist = 0;
        this.owner = owner;
    }
    update() {
        this.pos = this.pos.add(this.velocity);
        this.dist += this.velocity.mag();
        if (this.dist >= this.maxDist) this.dead = true;

        brawlers.forEach(b => {
            if (b.team !== this.team && !b.dead) {
                if (b.pos.sub(this.pos).mag() < b.radius + this.radius) {
                    b.takeDamage(this.damage, this.owner);
                    this.dead = true;
                    for(let i=0;i<4;i++) particles.push(new Particle(this.pos.x, this.pos.y, 8, this.team==='blue'?'#80D8FF':'#FF8A80', 10));
                }
            }
        });
    }
}

class Gem extends Entity {
    constructor(x, y) {
        super(x, y, 22); // „Ç®„É°„É©„É´„Éâ„ÇíÂ§ß„Åç„Åè (15 -> 22)
        this.floatY = 0;
    }
    update() {
        this.floatY = Math.sin(Date.now()/300)*5;
        brawlers.forEach(b => {
            if (!b.dead && b.pos.sub(this.pos).mag() < b.radius + this.radius) {
                this.dead = true;
                b.gemsHeld++;
                b.stats.gems++;
                Audio.playGem();
                spawnFloatingText("+1", b.pos.x, b.pos.y-50, '#D500F9');
            }
        });
    }
    draw() {
        CTX.save();
        CTX.translate(0, this.floatY);
        // Glow
        CTX.shadowColor = '#D500F9'; CTX.shadowBlur = 15;
        CTX.fillStyle = '#D500F9';
        CTX.beginPath();
        // Diamond shape
        CTX.moveTo(this.pos.x, this.pos.y - 18);
        CTX.lineTo(this.pos.x+18, this.pos.y);
        CTX.lineTo(this.pos.x, this.pos.y + 18);
        CTX.lineTo(this.pos.x-18, this.pos.y);
        CTX.fill();
        // Inner shine
        CTX.shadowBlur = 0;
        CTX.fillStyle = '#E040FB';
        CTX.beginPath();
        CTX.moveTo(this.pos.x, this.pos.y - 10);
        CTX.lineTo(this.pos.x+10, this.pos.y);
        CTX.lineTo(this.pos.x, this.pos.y + 10);
        CTX.lineTo(this.pos.x-10, this.pos.y);
        CTX.fill();
        CTX.restore();
    }
}

class Particle extends Entity {
    constructor(x, y, size, color, life) {
        super(x, y, size);
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.velocity = new Vector((Math.random()-0.5)*10, (Math.random()-0.5)*10);
    }
    update() {
        this.pos = this.pos.add(this.velocity);
        this.life--;
        if (this.life<=0) this.dead=true;
    }
}

let brawlers = [], projectiles = [], gems = [], particles = [];
let player;
let gemSpawnTimer = 0;
const inputs = { move: new Vector(0,0), aim: new Vector(0,0) };

function init() {
    setupJoystick('stick-left', 'move');
    setupJoystick('stick-right', 'aim');
    resize();
    floorPattern = createPattern('#262626', '#333', CONFIG.tileSize);
    loop();
}

function selectChar(type, el) {
    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
    playerType = type;
}

function startGame() {
    Audio.resume();
    Audio.startBGM();
    
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');

    brawlers = []; projectiles = []; gems = []; particles = [];
    gemSpawnTimer = 0;
    countdownActive = false;
    countdownTimer = CONFIG.winTime;
    winningTeam = null;
    
    player = new Brawler(200, CONFIG.mapHeight/2, 'blue', playerType, false, "YOU");
    brawlers.push(player);
    brawlers.push(new Brawler(200, CONFIG.mapHeight/2-300, 'blue', 'sniper', true, "ALLY 1"));
    brawlers.push(new Brawler(200, CONFIG.mapHeight/2+300, 'blue', 'tank', true, "ALLY 2"));
    
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2, 'red', 'fighter', true, "ENEMY 1"));
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2-300, 'red', 'sniper', true, "ENEMY 2"));
    brawlers.push(new Brawler(CONFIG.mapWidth-200, CONFIG.mapHeight/2+300, 'red', 'tank', true, "ENEMY 3"));

    gameActive = true;
}

function resetGame() {
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('main-menu').classList.remove('hidden');
}

function spawnFloatingText(text, x, y, color) {
    particles.push({ text: text, x: x, y: y, color: color, life: 60, isText: true });
}

function endGame(winner) {
    gameActive = false;
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('respawn-overlay').classList.add('hidden');
    
    const screen = document.getElementById('result-screen');
    const title = document.getElementById('result-title');
    screen.classList.remove('hidden');

    if (winner === 'blue') {
        title.innerText = "VICTORY!";
        title.style.color = "#40C4FF";
    } else {
        title.innerText = "DEFEAT";
        title.style.color = "#FF5252";
    }

    const tbody = document.getElementById('stats-body');
    tbody.innerHTML = '';
    brawlers.sort((a,b) => b.stats.kills - a.stats.kills).forEach(b => {
        const tr = document.createElement('tr');
        tr.className = b.team === 'blue' ? 'row-blue' : 'row-red';
        let name = b.name;
        tr.innerHTML = `<td>${name}</td><td>${b.stats.kills}</td><td>${b.stats.deaths}</td><td>${b.stats.gems}</td>`;
        tbody.appendChild(tr);
    });
}

function loop() {
    requestAnimationFrame(loop);
    
    CTX.fillStyle = '#111';
    CTX.fillRect(0,0, CANVAS.width, CANVAS.height);

    if (!gameActive) return;

    // --- GAME LOGIC ---

    // Gem Spawn: Âõ∫ÂÆö3Áßí (180 frames)
    gemSpawnTimer++;
    if (gemSpawnTimer >= CONFIG.gemSpawnRate && gems.length < 25) {
        gems.push(new Gem(CONFIG.mapWidth/2 + (Math.random()*200-100), CONFIG.mapHeight/2 + (Math.random()*200-100)));
        gemSpawnTimer = 0;
    }

    // Player Move
    if (inputs.move.mag() > 0.1 && !player.dead) {
        player.velocity = player.velocity.add(inputs.move.mult(0.9));
        if (player.velocity.mag() > player.speed) player.velocity = player.velocity.normalize().mult(player.speed);
    }

    // Update All
    [...brawlers, ...projectiles, ...gems, ...particles].forEach(e => {
        if (!e.isText) e.update(); else e.life--;
    });

    // --- VICTORY CONDITION CHECK ---
    let blueScore = brawlers.filter(b=>b.team==='blue').reduce((a,c)=>a+c.gemsHeld,0);
    let redScore = brawlers.filter(b=>b.team==='red').reduce((a,c)=>a+c.gemsHeld,0);
    
    document.getElementById('score-blue-val').innerText = blueScore;
    document.getElementById('score-red-val').innerText = redScore;

    let targetTeam = null;
    
    // Determine who is controlling the countdown
    if (blueScore >= CONFIG.winGemCount && blueScore > redScore) targetTeam = 'blue';
    else if (redScore >= CONFIG.winGemCount && redScore > blueScore) targetTeam = 'red';
    else if (blueScore >= CONFIG.winGemCount && blueScore === redScore) targetTeam = null; // Draw cancels count

    const cdText = document.getElementById('countdown-text');
    const cdOverlay = document.getElementById('countdown-overlay');

    if (targetTeam) {
        if (winningTeam !== targetTeam) {
            // New leader or start of count
            winningTeam = targetTeam;
            countdownTimer = CONFIG.winTime;
            countdownActive = true;
        } else {
            // Continue count
            countdownTimer -= 1/60;
        }

        cdOverlay.style.display = 'block';
        cdText.innerText = Math.ceil(countdownTimer);
        cdText.className = targetTeam === 'blue' ? 'countdown-text cd-blue' : 'countdown-text cd-red';
        
        // Sound tick
        if (Math.ceil(countdownTimer) !== Math.ceil(countdownTimer + 1/60)) Audio.playCount();

        if (countdownTimer <= 0) endGame(targetTeam);
    } else {
        // Reset
        winningTeam = null;
        countdownActive = false;
        countdownTimer = CONFIG.winTime;
        cdOverlay.style.display = 'none';
    }

    // Cleanup
    projectiles = projectiles.filter(p=>!p.dead);
    gems = gems.filter(g=>!g.dead);
    particles = particles.filter(p=>!p.dead && p.life > 0);

    // Camera
    let targetX = player.pos.x;
    let targetY = player.pos.y;
    camera.x += (targetX - camera.x) * 0.1;
    camera.y += (targetY - camera.y) * 0.1;

    // --- DRAWING ---
    CTX.save();
    CTX.translate(CANVAS.width/2, CANVAS.height/2);
    CTX.scale(CONFIG.cameraScale, CONFIG.cameraScale);
    CTX.translate(-camera.x, -camera.y);

    CTX.fillStyle = floorPattern;
    CTX.fillRect(0, 0, CONFIG.mapWidth, CONFIG.mapHeight);
    
    CTX.strokeStyle = '#444';
    CTX.lineWidth = 20;
    CTX.strokeRect(0,0,CONFIG.mapWidth, CONFIG.mapHeight);

    // Center Mine Area
    CTX.beginPath();
    CTX.arc(CONFIG.mapWidth/2, CONFIG.mapHeight/2, 140, 0, Math.PI*2);
    CTX.fillStyle = 'rgba(0,0,0,0.3)';
    CTX.fill();
    CTX.strokeStyle = '#E040FB';
    CTX.lineWidth = 5;
    CTX.setLineDash([15, 15]);
    CTX.stroke();
    CTX.setLineDash([]);

    gems.forEach(g => g.draw());

    brawlers.forEach(b => {
        if (b.dead) return;
        
        // Shadow
        CTX.fillStyle = 'rgba(0,0,0,0.4)';
        CTX.beginPath(); CTX.ellipse(b.pos.x, b.pos.y+15, b.radius*0.9, b.radius*0.5, 0, 0, Math.PI*2); CTX.fill();

        // Body
        CTX.fillStyle = b.color;
        CTX.beginPath(); CTX.arc(b.pos.x, b.pos.y, b.radius, 0, Math.PI*2); CTX.fill();
        CTX.strokeStyle = '#fff'; CTX.lineWidth = 4; CTX.stroke();

        // Aim Guide
        if (b === player && inputs.aim.mag() > 0.1) {
            CTX.save();
            CTX.translate(b.pos.x, b.pos.y);
            CTX.rotate(Math.atan2(inputs.aim.y, inputs.aim.x));
            CTX.fillStyle = 'rgba(255,255,255,0.3)';
            CTX.beginPath();
            if (b.type==='fighter') { CTX.moveTo(0,0); CTX.lineTo(b.range, -60); CTX.lineTo(b.range, 60); }
            else { CTX.fillRect(0, -15, b.range, 30); }
            CTX.fill();
            CTX.restore();
        }

        // HP Bar
        const hpPct = Math.max(0, b.hp / b.maxHp);
        CTX.fillStyle = '#222';
        CTX.fillRect(b.pos.x - 35, b.pos.y - 70, 70, 10);
        CTX.fillStyle = hpPct > 0.3 ? '#00E676' : '#FF1744';
        CTX.fillRect(b.pos.x - 35, b.pos.y - 70, 70*hpPct, 10);
        CTX.strokeStyle = '#000'; CTX.lineWidth = 1; CTX.strokeRect(b.pos.x - 35, b.pos.y - 70, 70, 10);

        // Reload Gauge (NEW)
        if (b.reloadTime > 0) {
            // cooldown goes from reloadTime -> 0.
            // We want gauge to fill from 0 -> 100 when cooldown is 0.
            const reloadPct = 1 - (b.cooldown / b.reloadTime);
            CTX.fillStyle = '#222';
            CTX.fillRect(b.pos.x - 35, b.pos.y - 58, 70, 6);
            CTX.fillStyle = reloadPct >= 1 ? '#FF9100' : '#AAA'; // Ready vs Loading
            CTX.fillRect(b.pos.x - 35, b.pos.y - 58, 70*reloadPct, 6);
            if (reloadPct < 1) { // Separators for visual style
                 CTX.fillStyle = 'rgba(255,255,255,0.5)';
                 CTX.fillRect(b.pos.x - 35 + (70*reloadPct), b.pos.y-58, 2, 6);
            }
        }

        // Name & Gems
        CTX.fillStyle = '#fff';
        CTX.font = "bold 18px 'M PLUS Rounded 1c'";
        CTX.textAlign = 'center';
        CTX.strokeStyle = 'black';
        CTX.lineWidth = 3;
        CTX.strokeText(b.name, b.pos.x, b.pos.y - 80);
        CTX.fillText(b.name, b.pos.x, b.pos.y - 80);

        if (b.gemsHeld > 0) {
            CTX.font = "bold 22px 'Fredoka'";
            CTX.fillStyle = '#fff';
            CTX.strokeText("üíé"+b.gemsHeld, b.pos.x, b.pos.y - 105);
            CTX.fillText("üíé"+b.gemsHeld, b.pos.x, b.pos.y - 105);
        }
    });

    projectiles.forEach(p => {
        CTX.fillStyle = p.team === 'blue' ? '#80D8FF' : '#FF8A80';
        CTX.beginPath(); CTX.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI*2); CTX.fill();
        CTX.strokeStyle='#fff'; CTX.lineWidth=2; CTX.stroke();
    });

    particles.forEach(p => {
        if (p.isText) {
            CTX.font = "bold 32px 'Fredoka'";
            CTX.fillStyle = p.color;
            CTX.strokeStyle = 'black'; CTX.lineWidth = 4;
            CTX.strokeText(p.text, p.x, p.y - (60-p.life));
            CTX.fillText(p.text, p.x, p.y - (60-p.life));
        } else {
            CTX.fillStyle = p.color; CTX.globalAlpha = p.life/p.maxLife;
            CTX.beginPath(); CTX.arc(p.pos.x, p.pos.y, p.radius * (p.life/p.maxLife), 0, Math.PI*2); CTX.fill();
            CTX.globalAlpha = 1;
        }
    });

    CTX.restore();
}

function resize() { CANVAS.width = window.innerWidth; CANVAS.height = window.innerHeight; }
function setupJoystick(id, type) {
    const zone = document.getElementById(id);
    const handle = zone.querySelector('.joystick-handle');
    let touchId = null, origin = {x:0, y:0};

    const handleStart = (e) => {
        e.preventDefault();
        const t = e.changedTouches ? e.changedTouches[0] : e;
        if(e.changedTouches) touchId = t.identifier;
        const r = zone.getBoundingClientRect();
        origin = {x: r.left+r.width/2, y: r.top+r.height/2};
        update(t.clientX, t.clientY);
    };
    const handleMove = (e) => {
        e.preventDefault();
        const t = e.changedTouches ? [...e.changedTouches].find(touch=>touch.identifier===touchId) : e;
        if(t) update(t.clientX, t.clientY);
    };
    const handleEnd = (e) => {
        e.preventDefault();
        touchId = null;
        handle.style.transform = `translate(-50%, -50%)`;
        if (type==='move') inputs.move = new Vector(0,0);
        else { if(inputs.aim.mag() > 0.2) player.shoot(inputs.aim); inputs.aim = new Vector(0,0); }
    };
    function update(cx, cy) {
        let dx = cx - origin.x, dy = cy - origin.y;
        let dist = Math.sqrt(dx*dx+dy*dy), angle = Math.atan2(dy,dx);
        let max = 60;
        if(dist>max) { dx = Math.cos(angle)*max; dy=Math.sin(angle)*max; }
        handle.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        let v = new Vector(dx/max, dy/max);
        if(type==='move') inputs.move = v; else inputs.aim = v;
    }
    zone.addEventListener('touchstart', handleStart, {passive:false});
    zone.addEventListener('touchmove', handleMove, {passive:false});
    zone.addEventListener('touchend', handleEnd, {passive:false});
    zone.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', e => { if(touchId!==null && !e.changedTouches) handleMove(e); });
    window.addEventListener('mouseup', e => { if(touchId!==null && !e.changedTouches) handleEnd(e); });
}

window.addEventListener('resize', resize);
window.onload = init;
</script>
</body>
</html>
